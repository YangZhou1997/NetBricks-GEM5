/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const RTE_EXEC_ENV: &'static [u8; 9usize] = b"linuxapp\0";
pub const RTE_ARCH: &'static [u8; 7usize] = b"x86_64\0";
pub const RTE_MACHINE: &'static [u8; 7usize] = b"native\0";
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_NEXT_ABI: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 8;
pub const RTE_MAX_MEMSEG: u32 = 256;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_LOG_LEVEL: u32 = 8;
pub const RTE_LOG_HISTORY: u32 = 256;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_EAL_IGB_UIO: u32 = 1;
pub const RTE_EAL_VFIO: u32 = 1;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_ENABLE_AVX: u32 = 1;
pub const RTE_EAL_PMD_PATH: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_EAL_VMWARE_TSC_MAP_SUPPORT: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_ETHER: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_EM_PMD: u32 = 1;
pub const RTE_LIBRTE_IGB_PMD: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_16BYTE_RX_DESC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_LIBRTE_I40E_ITR_INTERVAL: i32 = -1;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_MLX4_SGE_WR_N: u32 = 4;
pub const RTE_LIBRTE_MLX4_MAX_INLINE: u32 = 0;
pub const RTE_LIBRTE_MLX4_TX_MP_CACHE: u32 = 8;
pub const RTE_LIBRTE_MLX4_SOFT_COUNTERS: u32 = 1;
pub const RTE_LIBRTE_MLX5_TX_MP_CACHE: u32 = 8;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_TPUT: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_SFC_EFX_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_SZEDATA2_AS: u32 = 0;
pub const RTE_LIBRTE_THUNDERX_NICVF_PMD: u32 = 1;
pub const RTE_LIBRTE_LIO_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_USE_PHYS_IOVA: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_LIBRTE_PMD_RING: u32 = 1;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_PMD_PCAP: u32 = 1;
pub const RTE_LIBRTE_PMD_BOND: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_VF_TX_SWITCH: u32 = 1;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_LIBRTE_PMD_AF_PACKET: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PAD_TX: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_DEBUG_DRIVER: u32 = 1;
pub const RTE_LIBRTE_PMD_TAP: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_FAILSAFE: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_QAT_PMD_MAX_NB_SESSIONS: u32 = 2048;
pub const RTE_LIBRTE_PMD_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_LIBRTE_PMD_NULL_CRYPTO: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_LIBRTE_PMD_SKELETON_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SW_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX_SSOVF: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_DRIVER_MEMPOOL_RING: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_STACK: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_BITRATE: u32 = 1;
pub const RTE_LIBRTE_LATENCY_STATS: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_PMD_KNI: u32 = 1;
pub const RTE_KNI_KMOD: u32 = 1;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIBRTE_PMD_VHOST: u32 = 1;
pub const RTE_APP_TEST: u32 = 1;
pub const RTE_TEST_PMD: u32 = 1;
pub const RTE_APP_CRYPTO_PERF: u32 = 1;
pub const RTE_APP_EVENTDEV: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_BUILD_COMBINE_LIBS: u32 = 1;
pub const RTE_PCI_CONFIG: u32 = 1;
pub const RTE_PCI_EXTENDED_TAG: &'static [u8; 3usize] = b"on\0";
pub const RTE_PCI_MAX_READ_REQUEST_SIZE: u32 = 128;
pub const RTE_LIBRTE_EAL_LINUXAPP: u32 = 1;
pub const RTE_IXGBE_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_MLX5_SGE_WR_N: u32 = 4;
pub const RTE_LIBRTE_MLX5_MAX_INLINE: u32 = 0;
pub const RTE_AESNI_MB_PMD_MAX_NB_QUEUE_PAIRS: u32 = 8;
pub const RTE_AESNI_MB_PMD_MAX_NB_SESSIONS: u32 = 2048;
pub const RTE_RING_PAUSE_REP_COUNT: u32 = 0;
pub const RTE_LIBRTE_MBUF_OFFLOAD: u32 = 1;
pub const RTE_KNI_VHOST_MAX_CACHE_SIZE: u32 = 1024;
pub const RTE_LIBRTE_VHOST_USER: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_64: u32 = 1;
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const MPLOCKED: &'static [u8; 8usize] = b"lock ; \0";
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const _SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const __defined_schedparam: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _PTHREAD_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 32;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 32;
pub const __ELASTERROR: u32 = 1000;
pub const _STRING_H: u32 = 1;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const ALIGNMENT_MASK: u32 = 15;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _RTE_RTM_H_: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 10;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const DOM0_NAME_MAX: u32 = 256;
pub const DOM0_MM_DEV: &'static [u8; 13usize] = b"/dev/dom0_mm\0";
pub const DOM0_CONTIG_NUM_ORDER: u32 = 9;
pub const DOM0_NUM_MEMSEG: u32 = 512;
pub const DOM0_MEMBLOCK_SIZE: u32 = 2097152;
pub const DOM0_CONFIG_MEMSIZE: u32 = 4096;
pub const DOM0_NUM_MEMBLOCK: u32 = 2048;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\0";
pub const PROD_ALIGN: u32 = 128;
pub const CONS_ALIGN: u32 = 128;
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const __IS_SP: u32 = 1;
pub const __IS_MP: u32 = 0;
pub const __IS_SC: u32 = 1;
pub const __IS_MC: u32 = 0;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\0";
pub const MEMPOOL_PG_NUM_DEFAULT: u32 = 1;
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const MEMPOOL_F_NO_PHYS_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const PKT_RX_VLAN_PKT: u32 = 1;
pub const PKT_RX_RSS_HASH: u32 = 2;
pub const PKT_RX_FDIR: u32 = 4;
pub const PKT_RX_L4_CKSUM_BAD: u32 = 8;
pub const PKT_RX_IP_CKSUM_BAD: u32 = 16;
pub const PKT_RX_EIP_CKSUM_BAD: u32 = 32;
pub const PKT_RX_VLAN_STRIPPED: u32 = 64;
pub const PKT_RX_IP_CKSUM_MASK: u32 = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_IP_CKSUM_GOOD: u32 = 128;
pub const PKT_RX_IP_CKSUM_NONE: u32 = 144;
pub const PKT_RX_L4_CKSUM_MASK: u32 = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_L4_CKSUM_GOOD: u32 = 256;
pub const PKT_RX_L4_CKSUM_NONE: u32 = 264;
pub const PKT_RX_IEEE1588_PTP: u32 = 512;
pub const PKT_RX_IEEE1588_TMST: u32 = 1024;
pub const PKT_RX_FDIR_ID: u32 = 8192;
pub const PKT_RX_FDIR_FLX: u32 = 16384;
pub const PKT_RX_QINQ_STRIPPED: u32 = 32768;
pub const PKT_RX_QINQ_PKT: u32 = 32768;
pub const PKT_RX_LRO: u32 = 65536;
pub const PKT_RX_TIMESTAMP: u32 = 131072;
pub const PKT_TX_MACSEC: u64 = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const PKT_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const PKT_TX_QINQ_PKT: u64 = 562949953421312;
pub const PKT_TX_TCP_SEG: u64 = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: u32 = 0;
pub const PKT_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const PKT_TX_L4_MASK: u64 = 13510798882111488;
pub const PKT_TX_IP_CKSUM: u64 = 18014398509481984;
pub const PKT_TX_IPV4: u64 = 36028797018963968;
pub const PKT_TX_IPV6: u64 = 72057594037927936;
pub const PKT_TX_VLAN_PKT: u64 = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const PKT_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: u64 = 468356769060487168;
pub const __RESERVED: u64 = 2305843009213693952;
pub const IND_ATTACHED_MBUF: u64 = 4611686018427387904;
pub const CTRL_MBUF_FLAG: i64 = -9223372036854775808;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const ETHER_ADDR_LEN: u32 = 6;
pub const ETHER_TYPE_LEN: u32 = 2;
pub const ETHER_CRC_LEN: u32 = 4;
pub const ETHER_HDR_LEN: u32 = 14;
pub const ETHER_MIN_LEN: u32 = 64;
pub const ETHER_MAX_LEN: u32 = 1518;
pub const ETHER_MTU: u32 = 1500;
pub const ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const ETHER_MAX_VLAN_ID: u32 = 4095;
pub const ETHER_MIN_MTU: u32 = 68;
pub const ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const ETHER_GROUP_ADDR: u32 = 1;
pub const ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const ETHER_TYPE_IPv4: u32 = 2048;
pub const ETHER_TYPE_IPv6: u32 = 34525;
pub const ETHER_TYPE_ARP: u32 = 2054;
pub const ETHER_TYPE_RARP: u32 = 32821;
pub const ETHER_TYPE_VLAN: u32 = 33024;
pub const ETHER_TYPE_QINQ: u32 = 34984;
pub const ETHER_TYPE_1588: u32 = 35063;
pub const ETHER_TYPE_SLOW: u32 = 34825;
pub const ETHER_TYPE_TEB: u32 = 25944;
pub const ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_MAX: u32 = 22;
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_FLEX_FILTER_MAXLEN: u32 = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const TCP_URG_FLAG: u32 = 32;
pub const TCP_ACK_FLAG: u32 = 16;
pub const TCP_PSH_FLAG: u32 = 8;
pub const TCP_RST_FLAG: u32 = 4;
pub const TCP_SYN_FLAG: u32 = 2;
pub const TCP_FIN_FLAG: u32 = 1;
pub const TCP_FLAG_ALL: u32 = 63;
pub const ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const ETH_LINK_SPEED_FIXED: u32 = 1;
pub const ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const ETH_LINK_SPEED_10M: u32 = 4;
pub const ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const ETH_LINK_SPEED_100M: u32 = 16;
pub const ETH_LINK_SPEED_1G: u32 = 32;
pub const ETH_LINK_SPEED_2_5G: u32 = 64;
pub const ETH_LINK_SPEED_5G: u32 = 128;
pub const ETH_LINK_SPEED_10G: u32 = 256;
pub const ETH_LINK_SPEED_20G: u32 = 512;
pub const ETH_LINK_SPEED_25G: u32 = 1024;
pub const ETH_LINK_SPEED_40G: u32 = 2048;
pub const ETH_LINK_SPEED_50G: u32 = 4096;
pub const ETH_LINK_SPEED_56G: u32 = 8192;
pub const ETH_LINK_SPEED_100G: u32 = 16384;
pub const ETH_SPEED_NUM_NONE: u32 = 0;
pub const ETH_SPEED_NUM_10M: u32 = 10;
pub const ETH_SPEED_NUM_100M: u32 = 100;
pub const ETH_SPEED_NUM_1G: u32 = 1000;
pub const ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const ETH_SPEED_NUM_5G: u32 = 5000;
pub const ETH_SPEED_NUM_10G: u32 = 10000;
pub const ETH_SPEED_NUM_20G: u32 = 20000;
pub const ETH_SPEED_NUM_25G: u32 = 25000;
pub const ETH_SPEED_NUM_40G: u32 = 40000;
pub const ETH_SPEED_NUM_50G: u32 = 50000;
pub const ETH_SPEED_NUM_56G: u32 = 56000;
pub const ETH_SPEED_NUM_100G: u32 = 100000;
pub const ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const ETH_LINK_DOWN: u32 = 0;
pub const ETH_LINK_UP: u32 = 1;
pub const ETH_LINK_FIXED: u32 = 0;
pub const ETH_LINK_AUTONEG: u32 = 1;
pub const ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const ETH_RSS_IPV4: u32 = 4;
pub const ETH_RSS_FRAG_IPV4: u32 = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const ETH_RSS_IPV6: u32 = 256;
pub const ETH_RSS_FRAG_IPV6: u32 = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const ETH_RSS_IPV6_EX: u32 = 32768;
pub const ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const ETH_RSS_PORT: u32 = 262144;
pub const ETH_RSS_VXLAN: u32 = 524288;
pub const ETH_RSS_GENEVE: u32 = 1048576;
pub const ETH_RSS_NVGRE: u32 = 2097152;
pub const ETH_RSS_IP: u32 = 41868;
pub const ETH_RSS_UDP: u32 = 133152;
pub const ETH_RSS_TCP: u32 = 66576;
pub const ETH_RSS_SCTP: u32 = 4160;
pub const ETH_RSS_TUNNEL: u32 = 3670016;
pub const ETH_RSS_PROTO_MASK: u32 = 4194300;
pub const ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_PG_SUPPORT: u32 = 1;
pub const ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const ETH_VLAN_STRIP_MASK: u32 = 1;
pub const ETH_VLAN_FILTER_MASK: u32 = 2;
pub const ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const ETH_VLAN_ID_MAX: u32 = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const ETH_MIRROR_MAX_VLANS: u32 = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: u32 = 1;
pub const ETH_MIRROR_UPLINK_PORT: u32 = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: u32 = 4;
pub const ETH_MIRROR_VLAN: u32 = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: u32 = 16;
pub const ETH_TXQ_FLAGS_NOMULTSEGS: u32 = 1;
pub const ETH_TXQ_FLAGS_NOREFCOUNT: u32 = 2;
pub const ETH_TXQ_FLAGS_NOMULTMEMP: u32 = 4;
pub const ETH_TXQ_FLAGS_NOVLANOFFL: u32 = 256;
pub const ETH_TXQ_FLAGS_NOXSUMSCTP: u32 = 512;
pub const ETH_TXQ_FLAGS_NOXSUMUDP: u32 = 1024;
pub const ETH_TXQ_FLAGS_NOXSUMTCP: u32 = 2048;
pub const ETH_TXQ_FLAGS_NOOFFLOADS: u32 = 3840;
pub const ETH_TXQ_FLAGS_NOXSUMS: u32 = 3584;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const ETH_DCB_NUM_TCS: u32 = 8;
pub const ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const ETH_L2_TUNNEL_ENABLE_MASK: u32 = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: u32 = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: u32 = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: u32 = 8;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 32;
pub const RTE_ETH_DEV_DETACHABLE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_TIMER_STOP: u32 = 0;
pub const RTE_TIMER_PENDING: u32 = 1;
pub const RTE_TIMER_RUNNING: u32 = 2;
pub const RTE_TIMER_CONFIG: u32 = 3;
pub const RTE_TIMER_NO_OWNER: i32 = -2;
pub const MAX_SKIPLIST_DEPTH: u32 = 10;
pub const PCI_PRI_FMT: &'static [u8; 18usize] = b"%.4x:%.2x:%.2x.%x\0";
pub const PCI_SHORT_PRI_FMT: &'static [u8; 13usize] = b"%.2x:%.2x.%x\0";
pub const PCI_FMT_NVAL: u32 = 4;
pub const PCI_RESOURCE_FMT_NVAL: u32 = 3;
pub const PCI_MAX_RESOURCE: u32 = 6;
pub const PCI_ANY_ID: u32 = 65535;
pub const RTE_CLASS_ANY_ID: u32 = 16777215;
pub const RTE_PCI_DRV_NEED_MAPPING: u32 = 1;
pub const RTE_PCI_DRV_INTR_LSC: u32 = 8;
pub const RTE_PCI_DRV_INTR_RMV: u32 = 16;
pub const RTE_PCI_DRV_KEEP_MAPPED_RES: u32 = 32;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub __wait_terminated: wait__bindgen_ty_1,
    pub __wait_stopped: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_termsig: ::std::os::raw::c_uint,
        __w_coredump: ::std::os::raw::c_uint,
        __w_retcode: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __w_stopval: ::std::os::raw::c_uint,
        __w_stopsig: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_terminated as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).__wait_stopped as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(__wait_stopped)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS {
    pub __uptr: *mut wait,
    pub __iptr: *mut ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Size of: ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<__WAIT_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(__WAIT_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__uptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__uptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__iptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__WAIT_STATUS),
            "::",
            stringify!(__iptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__rwelision as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
extern "C" {
    #[doc = " Function to terminate the application immediately, printing an error"]
    #[doc = " message and returning the exit_code back to the shell."]
    #[doc = ""]
    #[doc = " This function never returns"]
    #[doc = ""]
    #[doc = " @param exit_code"]
    #[doc = "     The exit code to be returned by the application"]
    #[doc = " @param format"]
    #[doc = "     The format string to be used for printing the message. This can include"]
    #[doc = "     printf format characters which will be expanded using any further parameters"]
    #[doc = "     to the function."]
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
#[doc = " The rte_log structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_logs {
    #[doc = "< Bitfield with enabled logs."]
    pub type_: u32,
    #[doc = "< Log level."]
    pub level: u32,
    #[doc = "< Output file set by rte_openlog_stream, or NULL."]
    pub file: *mut FILE,
    pub dynamic_types_len: usize,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(
        ::std::mem::size_of::<rte_logs>(),
        32usize,
        concat!("Size of: ", stringify!(rte_logs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_logs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_logs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types)
        )
    );
}
extern "C" {
    pub static mut rte_logs: rte_logs;
}
extern "C" {
    #[doc = " Change the stream that will be used by the logging system."]
    #[doc = ""]
    #[doc = " This can be done at any time. The f argument represents the stream"]
    #[doc = " to be used to send the logs. If f is NULL, the default output is"]
    #[doc = " used (stderr)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   Pointer to the stream."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative on error."]
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the global log level."]
    #[doc = ""]
    #[doc = " After this call, logs with a level lower or equal than the level"]
    #[doc = " passed as argument will be displayed."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    #[doc = " Deprecated, replaced by rte_log_set_global_level()."]
    pub fn rte_set_log_level(level: u32);
}
extern "C" {
    #[doc = " Get the global log level."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The current global log level."]
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    #[doc = " Deprecated, replaced by rte_log_get_global_level()."]
    pub fn rte_get_log_level() -> u32;
}
extern "C" {
    #[doc = " Enable or disable the log type."]
    #[doc = ""]
    #[doc = " @param type"]
    #[doc = "   Log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param enable"]
    #[doc = "   True for enable; false for disable."]
    pub fn rte_set_log_type(type_: u32, enable: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the global log type."]
    pub fn rte_get_log_type() -> u32;
}
extern "C" {
    #[doc = " Get the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype is invalid."]
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type."]
    #[doc = ""]
    #[doc = " @param pattern"]
    #[doc = "   The regexp identifying the log type."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if level is invalid."]
    pub fn rte_log_set_level_regexp(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the log level for a given type."]
    #[doc = ""]
    #[doc = " @param logtype"]
    #[doc = "   The log type identifier."]
    #[doc = " @param level"]
    #[doc = "   The level to be set."]
    #[doc = " @return"]
    #[doc = "   0 on success, a negative value if logtype or level is invalid."]
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current loglevel for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The loglevel of the message being processed."]
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current logtype for the message being processed."]
    #[doc = ""]
    #[doc = " Before calling the user-defined stream for logging, the log"]
    #[doc = " subsystem sets a per-lcore variable containing the loglevel and the"]
    #[doc = " logtype of the message being processed. This information can be"]
    #[doc = " accessed by the user-defined log output function through this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The logtype of the message being processed."]
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a dynamic log type"]
    #[doc = ""]
    #[doc = " If a log is already registered with the same type, the returned value"]
    #[doc = " is the same than the previous one."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The string identifying the log type."]
    #[doc = " @return"]
    #[doc = "   - >0: success, the returned value is the log type identifier."]
    #[doc = "   - (-ENONEM): cannot allocate memory."]
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump log information."]
    #[doc = ""]
    #[doc = " Dump the global level and the registered log types."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The output stream where the dump should be sent."]
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the global rte_logs variable."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generates a log message."]
    #[doc = ""]
    #[doc = " The message will be sent in the stream defined by the previous call"]
    #[doc = " to rte_openlog_stream()."]
    #[doc = ""]
    #[doc = " The level argument determines if the log should be displayed or"]
    #[doc = " not, depending on the global rte_logs variable. A trailing"]
    #[doc = " newline may be added if needed."]
    #[doc = ""]
    #[doc = " The preferred alternative is the RTE_LOG() because it adds the"]
    #[doc = " level and type in the logged string."]
    #[doc = ""]
    #[doc = " @param level"]
    #[doc = "   Log level. A value between RTE_LOG_EMERG (1) and RTE_LOG_DEBUG (8)."]
    #[doc = " @param logtype"]
    #[doc = "   The log type, for example, RTE_LOGTYPE_EAL."]
    #[doc = " @param format"]
    #[doc = "   The format string, as in printf(3), followed by the variable arguments"]
    #[doc = "   required by the format."]
    #[doc = " @param ap"]
    #[doc = "   The va_list of the variable arguments required by the format."]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - Negative on error."]
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the stack of the calling core to the console."]
    pub fn rte_dump_stack();
}
extern "C" {
    #[doc = " Dump the registers of the calling core to the console."]
    #[doc = ""]
    #[doc = " Note: Not implemented in a userapp environment; use gdb instead."]
    pub fn rte_dump_registers();
}
extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic16_t {
    #[doc = "< An internal counter value."]
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic16_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic32_t {
    #[doc = "< An internal counter value."]
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic32_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic32_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[doc = " The atomic counter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic64_t {
    #[doc = "< Internal counter value."]
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic64_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic64_t),
            "::",
            stringify!(cnt)
        )
    );
}
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = u32;
extern "C" {
    pub static mut eal_timer_source: timer_source;
}
extern "C" {
    #[doc = " Get the measured frequency of the RDTSC counter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The TSC frequency for this lcore"]
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    #[doc = " Blocking delay function."]
    #[doc = ""]
    #[doc = " @param us"]
    #[doc = "   Number of microseconds to wait."]
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Replace rte_delay_us with user defined function."]
    #[doc = ""]
    #[doc = " @param userfunc"]
    #[doc = "   User function which replaces rte_delay_us. rte_delay_us_block restores"]
    #[doc = "   buildin block delay function."]
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub static mut rte_cycles_vmware_tsc_map: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_2 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = u32;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_3 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_3 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_3 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_3 = 0;
pub type _bindgen_ty_3 = u32;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_4 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_4 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_4 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = u32;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_5 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_5 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = u32;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_6 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_6 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_6 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_6 = 0;
pub type _bindgen_ty_6 = u32;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_7 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = u32;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_8 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = u32;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_9 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = u32;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_11 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = u32;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
#[doc = " The lcore role (used in RTE or not)."]
pub type rte_lcore_role_t = u32;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
#[doc = " The type of process in a linuxapp, multi-process setup"]
pub type rte_proc_type_t = i32;
#[doc = " The global RTE configuration structure."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_config {
    #[doc = "< Id of the master lcore"]
    pub master_lcore: u32,
    #[doc = "< Number of available logical cores."]
    pub lcore_count: u32,
    #[doc = "< Number of available service cores."]
    pub service_lcore_count: u32,
    #[doc = "< State of cores."]
    pub lcore_role: [rte_lcore_role_t; 128usize],
    #[doc = " Primary or secondary configuration"]
    pub process_type: rte_proc_type_t,
    #[doc = " Pointer to memory configuration, which may be shared across multiple"]
    #[doc = " DPDK instances"]
    pub mem_config: *mut rte_mem_config,
}
#[test]
fn bindgen_test_layout_rte_config() {
    assert_eq!(
        ::std::mem::size_of::<rte_config>(),
        536usize,
        concat!("Size of: ", stringify!(rte_config))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_config>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).master_lcore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(master_lcore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).lcore_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(lcore_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).service_lcore_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(service_lcore_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).lcore_role as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(lcore_role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).process_type as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(process_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_config>())).mem_config as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_config),
            "::",
            stringify!(mem_config)
        )
    );
}
extern "C" {
    #[doc = " Get the global configuration structure."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   A pointer to the global configuration structure."]
    pub fn rte_eal_get_configuration() -> *mut rte_config;
}
extern "C" {
    #[doc = " Get a lcore's role."]
    #[doc = ""]
    #[doc = " @param lcore_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   The role of the lcore."]
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
extern "C" {
    #[doc = " Get the process type in a multi-process setup"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    #[doc = " Request iopl privilege for all RPL."]
    #[doc = ""]
    #[doc = " This function should be called by pmds which need access to ioports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, returns 0."]
    #[doc = "   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL)."]
    #[doc = ""]
    #[doc = " This function is to be executed on the MASTER lcore only, as soon"]
    #[doc = " as possible in the application's main() function."]
    #[doc = ""]
    #[doc = " The function finishes the initialization process before main() is called."]
    #[doc = " It puts the SLAVE lcores in the WAIT state."]
    #[doc = ""]
    #[doc = " When the multi-partition feature is supported, depending on the"]
    #[doc = " configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this"]
    #[doc = " function waits to ensure that the magic number is set before"]
    #[doc = " returning. See also the rte_eal_get_configuration() function. Note:"]
    #[doc = " This behavior may change in the future."]
    #[doc = ""]
    #[doc = " @param argc"]
    #[doc = "   A non-negative value.  If it is greater than 0, the array members"]
    #[doc = "   for argv[0] through argv[argc] (non-inclusive) shall contain pointers"]
    #[doc = "   to strings."]
    #[doc = " @param argv"]
    #[doc = "   An array of strings.  The contents of the array, as well as the strings"]
    #[doc = "   which are pointed to by the array, may be modified by this function."]
    #[doc = " @return"]
    #[doc = "   - On success, the number of parsed arguments, which is greater or"]
    #[doc = "     equal to zero. After the call to rte_eal_init(),"]
    #[doc = "     all arguments argv[x] with x < ret may have been modified by this"]
    #[doc = "     function call and should not be further interpreted by the"]
    #[doc = "     application.  The EAL does not take any ownership of the memory used"]
    #[doc = "     for either the argv array, or its members."]
    #[doc = "   - On failure, -1 and rte_errno is set to a value indicating the cause"]
    #[doc = "     for failure.  In some instances, the application will need to be"]
    #[doc = "     restarted as part of clearing the issue."]
    #[doc = ""]
    #[doc = "   Error codes returned via rte_errno:"]
    #[doc = "     EACCES indicates a permissions issue."]
    #[doc = ""]
    #[doc = "     EAGAIN indicates either a bus or system resource was not available,"]
    #[doc = "            setup may be attempted again."]
    #[doc = ""]
    #[doc = "     EALREADY indicates that the rte_eal_init function has already been"]
    #[doc = "              called, and cannot be called again."]
    #[doc = ""]
    #[doc = "     EFAULT indicates the tailq configuration name was not found in"]
    #[doc = "            memory configuration."]
    #[doc = ""]
    #[doc = "     EINVAL indicates invalid parameters were passed as argv/argc."]
    #[doc = ""]
    #[doc = "     ENOMEM indicates failure likely caused by an out-of-memory condition."]
    #[doc = ""]
    #[doc = "     ENODEV indicates memory setup issues."]
    #[doc = ""]
    #[doc = "     ENOTSUP indicates that the EAL cannot initialize on this system."]
    #[doc = ""]
    #[doc = "     EPROTO indicates that the PCI bus is either not present, or is not"]
    #[doc = "            readable by the eal."]
    #[doc = ""]
    #[doc = "     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a primary process is currently alive"]
    #[doc = ""]
    #[doc = " This function returns true when a primary process is currently"]
    #[doc = " active."]
    #[doc = ""]
    #[doc = " @param config_file_path"]
    #[doc = "   The config_file_path argument provided should point at the location"]
    #[doc = "   that the primary process will create its config file. If NULL, the default"]
    #[doc = "   config file path is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - If alive, returns 1."]
    #[doc = "  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Usage function typedef used by the application usage function."]
#[doc = ""]
#[doc = " Use this function typedef to define and call rte_set_applcation_usage_hook()"]
#[doc = " routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine."]
    #[doc = ""]
    #[doc = " This function allows the application to include its usage message"]
    #[doc = " in the EAL system usage message. The routine rte_set_application_usage_hook()"]
    #[doc = " needs to be called before the rte_eal_init() routine in the application."]
    #[doc = ""]
    #[doc = " This routine is optional for the application and will behave as if the set"]
    #[doc = " routine was never called as the default behavior."]
    #[doc = ""]
    #[doc = " @param usage_func"]
    #[doc = "   The func argument is a function pointer to the application usage routine."]
    #[doc = "   Called function is defined using rte_usage_hook_t typedef, which is of"]
    #[doc = "   the form void rte_usage_func(const char * prgname)."]
    #[doc = ""]
    #[doc = "   Calling this routine with a NULL value will reset the usage hook routine and"]
    #[doc = "   return the current value, which could be NULL."]
    #[doc = " @return"]
    #[doc = "   - Returns the current value of the rte_application_usage pointer to allow"]
    #[doc = "     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option)."]
    #[doc = " The no-huge mode cannot be used with UIO poll-mode drivers like igb/ixgbe."]
    #[doc = " It is useful for NIC drivers (e.g. librte_pmd_mlx4, librte_pmd_vmxnet3) or"]
    #[doc = " crypto drivers (e.g. librte_crypto_nitrox) provided by third-parties such"]
    #[doc = " as 6WIND."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A wrap API for syscall gettid."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, returns the thread ID of calling process."]
    #[doc = "   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
#[doc = " Function to be registered for the specific interrupt"]
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UNKNOWN: rte_intr_handle_type = 0;
#[doc = "< uio device handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO: rte_intr_handle_type = 1;
#[doc = "< uio generic handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO_INTX: rte_intr_handle_type = 2;
#[doc = "< vfio device handle (legacy)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_LEGACY: rte_intr_handle_type = 3;
#[doc = "< vfio device handle (MSI)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSI: rte_intr_handle_type = 4;
#[doc = "< vfio device handle (MSIX)"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSIX: rte_intr_handle_type = 5;
#[doc = "< alarm handle"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_ALARM: rte_intr_handle_type = 6;
#[doc = "< external handler"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_EXT: rte_intr_handle_type = 7;
#[doc = "< virtual device"]
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VDEV: rte_intr_handle_type = 8;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_MAX: rte_intr_handle_type = 9;
pub type rte_intr_handle_type = u32;
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_data {
    #[doc = "< event type"]
    pub event: u32,
    #[doc = "< User data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< IN: callback fun"]
    pub cb_fun: rte_intr_event_cb_t,
    #[doc = "< IN: callback arg"]
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_epoll_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_data>(),
        32usize,
        concat!("Size of: ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_fun as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_fun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_data>())).cb_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_data),
            "::",
            stringify!(cb_arg)
        )
    );
}
pub const RTE_EPOLL_INVALID: _bindgen_ty_12 = 0;
pub const RTE_EPOLL_VALID: _bindgen_ty_12 = 1;
pub const RTE_EPOLL_EXEC: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = u32;
#[doc = " interrupt epoll event obj, taken by epoll_event.ptr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_event {
    #[doc = "< OUT: event status"]
    pub status: u32,
    #[doc = "< OUT: event fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< OUT: epoll instance the ev associated with"]
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[test]
fn bindgen_test_layout_rte_epoll_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_epoll_event>(),
        48usize,
        concat!("Size of: ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_epoll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_epoll_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_epoll_event>())).epdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_epoll_event),
            "::",
            stringify!(epdata)
        )
    );
}
#[doc = " Interrupt handle"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    #[doc = "< interrupt event file descriptor"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< handle type"]
    pub type_: rte_intr_handle_type,
    #[doc = "< max interrupt requested"]
    pub max_intr: u32,
    #[doc = "< number of available efd(event fd)"]
    pub nb_efd: u32,
    #[doc = "< intr vectors/efds mapping"]
    pub efds: [::std::os::raw::c_int; 32usize],
    pub elist: [rte_epoll_event; 32usize],
    #[doc = "< intr vector number array"]
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    #[doc = "< VFIO device file descriptor"]
    pub vfio_dev_fd: ::std::os::raw::c_int,
    #[doc = "< UIO config file descriptor"]
    #[doc = "for uio_pci_generic"]
    pub uio_cfg_fd: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_rte_intr_handle__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_handle__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).vfio_dev_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(vfio_dev_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_intr_handle__bindgen_ty_1>())).uio_cfg_fd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle__bindgen_ty_1),
            "::",
            stringify!(uio_cfg_fd)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_intr_handle() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_handle>(),
        1696usize,
        concat!("Size of: ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_intr_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).max_intr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(max_intr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).nb_efd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(nb_efd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).efds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(efds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).elist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_intr_handle>())).intr_vec as *const _ as usize },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_intr_handle),
            "::",
            stringify!(intr_vec)
        )
    );
}
extern "C" {
    #[doc = " It waits for events on the epoll instance."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller wait for events."]
    #[doc = " @param events"]
    #[doc = "   Memory area contains the events that will be available for the caller."]
    #[doc = " @param maxevents"]
    #[doc = "   Up to maxevents are returned, must greater than zero."]
    #[doc = " @param timeout"]
    #[doc = "   Specifying a timeout of -1 causes a block indefinitely."]
    #[doc = "   Specifying a timeout equal to zero cause to return immediately."]
    #[doc = " @return"]
    #[doc = "   - On success, returns the number of available event."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It performs control operations on epoll instance referred by the epfd."]
    #[doc = " It requests that the operation op be performed for the target fd."]
    #[doc = ""]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd on which the caller perform control operations."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the target fd."]
    #[doc = " @param fd"]
    #[doc = "   The target fd on which the control ops perform."]
    #[doc = " @param event"]
    #[doc = "   Describes the object linked to the fd."]
    #[doc = "   Note: The caller must take care the object deletion after CTL_DEL."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The function returns the per thread epoll instance."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   epfd the epoll instance referred to."]
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {ADD, DEL}."]
    #[doc = " @param vec"]
    #[doc = "   RX intr vector number added to the epoll instance wait list."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It deletes registered eventfds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " It enables the packet I/O interrupt event if it's necessary."]
    #[doc = " It creates event fd for each interrupt vector when MSIX is used,"]
    #[doc = " otherwise it multiplexes a single event fd."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    #[doc = " @param nb_efd"]
    #[doc = "   Number of interrupt vector trying to enable."]
    #[doc = "   The value 0 is not allowed."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It disables the packet I/O interrupt event."]
    #[doc = " It deletes registered eventfds and closes the open fds."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
extern "C" {
    #[doc = " The packet I/O interrupt on datapath is enabled or not."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The interrupt handle instance allows other causes or not."]
    #[doc = " Other causes stand for any none packet I/O interrupts."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The multiple interrupt vector capability of interrupt handle instance."]
    #[doc = " It returns zero if no multiple interrupt vector support."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "   Pointer to the interrupt handle."]
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It registers the callback for the specific interrupt. Multiple"]
    #[doc = " callbacks cal be registered at the same time."]
    #[doc = " @param intr_handle"]
    #[doc = "  Pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It unregisters the callback according to the specified interrupt handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = " @param cb"]
    #[doc = "  callback address."]
    #[doc = " @param cb_arg"]
    #[doc = "  address of parameter for callback, (void *)-1 means to remove all"]
    #[doc = "  registered which has the same callback address."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return the number of callback entities removed."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It enables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " It disables the interrupt for the specified handle."]
    #[doc = ""]
    #[doc = " @param intr_handle"]
    #[doc = "  pointer to the interrupt handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
pub const rte_kernel_driver_RTE_KDRV_UNKNOWN: rte_kernel_driver = 0;
pub const rte_kernel_driver_RTE_KDRV_IGB_UIO: rte_kernel_driver = 1;
pub const rte_kernel_driver_RTE_KDRV_VFIO: rte_kernel_driver = 2;
pub const rte_kernel_driver_RTE_KDRV_UIO_GENERIC: rte_kernel_driver = 3;
pub const rte_kernel_driver_RTE_KDRV_NIC_UIO: rte_kernel_driver = 4;
pub const rte_kernel_driver_RTE_KDRV_NONE: rte_kernel_driver = 5;
#[doc = " Device driver."]
pub type rte_kernel_driver = u32;
pub const rte_dev_policy_RTE_DEV_WHITELISTED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLACKLISTED: rte_dev_policy = 1;
#[doc = " Device policies."]
pub type rte_dev_policy = u32;
#[doc = " A generic memory resource representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mem_resource {
    #[doc = "< Physical address, 0 if not resource."]
    pub phys_addr: u64,
    #[doc = "< Length of the resource."]
    pub len: u64,
    #[doc = "< Virtual address, NULL when not mapped."]
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_resource>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " A structure describing a device driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver {
    #[doc = "< Next in list."]
    pub next: rte_driver__bindgen_ty_1,
    #[doc = "< Driver name."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Driver alias."]
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver>(),
        32usize,
        concat!("Size of: ", stringify!(rte_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).alias as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(alias)
        )
    );
}
#[doc = " A structure describing a generic device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    #[doc = "< Next device"]
    pub next: rte_device__bindgen_ty_1,
    #[doc = "< Device name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Associated driver"]
    pub driver: *const rte_driver,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    #[doc = "< Device user arguments"]
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_device>(),
        48usize,
        concat!("Size of: ", stringify!(rte_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).driver as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).numa_node as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).devargs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(devargs)
        )
    );
}
extern "C" {
    #[doc = " Initialize a driver specified by name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The pointer to a driver name to be initialized."]
    #[doc = " @param args"]
    #[doc = "   The pointer to arguments used by driver initialization."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative on error"]
    pub fn rte_vdev_init(
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Uninitalize a driver specified by name."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The pointer to a driver name to be initialized."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative on error"]
    pub fn rte_vdev_uninit(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach a device to a registered driver."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The device name, that refers to a pci device (or some private"]
    #[doc = "   way of designating a vdev device). Based on this device name, eal"]
    #[doc = "   will identify a driver capable of handling it and pass it to the"]
    #[doc = "   driver probing function."]
    #[doc = " @param devargs"]
    #[doc = "   Device arguments to be passed to the driver."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_dev_attach(
        name: *const ::std::os::raw::c_char,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Detach a device from its driver."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   A pointer to a rte_device structure."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_dev_detach(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Hotplug add a given device to a specific bus."]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is added to."]
    #[doc = " @param devname"]
    #[doc = "   The device name. Based on this device name, eal will identify a driver"]
    #[doc = "   capable of handling it and pass it to the driver probing function."]
    #[doc = " @param devargs"]
    #[doc = "   Device arguments to be passed to the driver."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Hotplug remove a given device from a specific bus."]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   The bus name the device is removed from."]
    #[doc = " @param devname"]
    #[doc = "   The device name being removed."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Device comparison function."]
#[doc = ""]
#[doc = " This type of function is used to compare an rte_device with arbitrary"]
#[doc = " data."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "   Device handle."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "   Data to compare against. The type of this parameter is determined by"]
#[doc = "   the kind of comparison performed by the function."]
#[doc = ""]
#[doc = " @return"]
#[doc = "   0 if the device matches the data."]
#[doc = "   !0 if the device does not match."]
#[doc = "   <0 if ordering is possible and the device is lower than the data."]
#[doc = "   >0 if ordering is possible and the device is greater than the data."]
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Double linked list of buses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[doc = " Bus specific scan for devices attached on the bus."]
#[doc = " For each bus object, the scan would be responsible for finding devices and"]
#[doc = " adding them to its private device list."]
#[doc = ""]
#[doc = " A bus should mandatorily implement this method."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful scan"]
#[doc = "\t<0 for unsuccessful scan with error value"]
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " This is called while iterating over each registered bus."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 for successful probe"]
#[doc = "\t!0 for any error while probing"]
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " Device iterator to find a device on a bus."]
#[doc = ""]
#[doc = " This function returns an rte_device if one of those held by the bus"]
#[doc = " matches the data passed as parameter."]
#[doc = ""]
#[doc = " If the comparison function returns zero this function should stop iterating"]
#[doc = " over any more devices. To continue a search the device of a previous search"]
#[doc = " can be passed via the start parameter."]
#[doc = ""]
#[doc = " @param cmp"]
#[doc = "\tComparison function."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare each device against."]
#[doc = ""]
#[doc = " @param start"]
#[doc = "\tstarting point for the iteration"]
#[doc = ""]
#[doc = " @return"]
#[doc = "\tThe first device matching the data, NULL if none exists."]
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
#[doc = " Implementation specific probe function which is responsible for linking"]
#[doc = " devices on that bus with applicable drivers."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Implementation specific remove function which is responsible for unlinking"]
#[doc = " devices on that bus from assigned driver."]
#[doc = ""]
#[doc = " @param dev"]
#[doc = "\tDevice pointer that was returned by a previous call to find_device."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 on success."]
#[doc = "\t!0 on error."]
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
#[doc = " Bus specific parsing function."]
#[doc = " Validates the syntax used in the textual representation of a device,"]
#[doc = " If the syntax is valid and ``addr`` is not NULL, writes the bus-specific"]
#[doc = " device representation to ``addr``."]
#[doc = ""]
#[doc = " @param[in] name"]
#[doc = "\tdevice textual description"]
#[doc = ""]
#[doc = " @param[out] addr"]
#[doc = "\tdevice information location address, into which parsed info"]
#[doc = "\tshould be written. If NULL, nothing should be written, which"]
#[doc = "\tis not an error."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if parsing was successful."]
#[doc = "\t!0 for any error."]
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_UNDEFINED: rte_bus_scan_mode = 0;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_WHITELIST: rte_bus_scan_mode = 1;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_BLACKLIST: rte_bus_scan_mode = 2;
#[doc = " Bus scan policies"]
pub type rte_bus_scan_mode = u32;
#[doc = " A structure used to configure bus operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_conf {
    #[doc = "< Scan policy."]
    pub scan_mode: rte_bus_scan_mode,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_conf>())).scan_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_conf),
            "::",
            stringify!(scan_mode)
        )
    );
}
#[doc = " A structure describing a generic bus."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus {
    #[doc = "< Next bus object in linked list"]
    pub next: rte_bus__bindgen_ty_1,
    #[doc = "< Name of the bus"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Scan for devices attached to bus"]
    pub scan: rte_bus_scan_t,
    #[doc = "< Probe devices on bus"]
    pub probe: rte_bus_probe_t,
    #[doc = "< Find a device on the bus"]
    pub find_device: rte_bus_find_device_t,
    #[doc = "< Probe single device for drivers"]
    pub plug: rte_bus_plug_t,
    #[doc = "< Remove single device from driver"]
    pub unplug: rte_bus_unplug_t,
    #[doc = "< Parse a device name"]
    pub parse: rte_bus_parse_t,
    #[doc = "< Bus configuration"]
    pub conf: rte_bus_conf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus>(),
        80usize,
        concat!("Size of: ", stringify!(rte_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).scan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).probe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).find_device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(find_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).plug as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).unplug as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).parse as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(conf)
        )
    );
}
extern "C" {
    #[doc = " Register a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be registered."]
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Unregister a Bus handler."]
    #[doc = ""]
    #[doc = " @param bus"]
    #[doc = "   A pointer to a rte_bus structure describing the bus"]
    #[doc = "   to be unregistered."]
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    #[doc = " Scan all the buses."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 in case of success in scanning all buses"]
    #[doc = "  !0 in case of failure to scan"]
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For each device on the buses, perform a driver 'match' and call the"]
    #[doc = " driver-specific probe for device initialization."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t 0 for successful match/probe"]
    #[doc = "\t!0 otherwise"]
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump information of all the buses registered with EAL."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "\t A valid and open output stream handle"]
    pub fn rte_bus_dump(f: *mut FILE);
}
#[doc = " Bus comparison function."]
#[doc = ""]
#[doc = " @param bus"]
#[doc = "\tBus under test."]
#[doc = ""]
#[doc = " @param data"]
#[doc = "\tData to compare against."]
#[doc = ""]
#[doc = " @return"]
#[doc = "\t0 if the bus matches the data."]
#[doc = "\t!0 if the bus does not match."]
#[doc = "\t<0 if ordering is possible and the bus is lower than the data."]
#[doc = "\t>0 if ordering is possible and the bus is greater than the data."]
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *const rte_bus,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Bus iterator to find a particular bus."]
    #[doc = ""]
    #[doc = " This function compares each registered bus to find one that matches"]
    #[doc = " the data passed as parameter."]
    #[doc = ""]
    #[doc = " If the comparison function returns zero this function will stop iterating"]
    #[doc = " over any more buses. To continue a search the bus of a previous search can"]
    #[doc = " be passed via the start parameter."]
    #[doc = ""]
    #[doc = " @param start"]
    #[doc = "\tStarting point for the iteration."]
    #[doc = ""]
    #[doc = " @param cmp"]
    #[doc = "\tComparison function."]
    #[doc = ""]
    #[doc = " @param data"]
    #[doc = "\t Data to pass to comparison function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "\t A pointer to a rte_bus structure or NULL in case no bus matches"]
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a particular device."]
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    #[doc = " Find the registered bus for a given name."]
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
pub const rte_devtype_RTE_DEVTYPE_WHITELISTED_PCI: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLACKLISTED_PCI: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
#[doc = " Type of generic device"]
pub type rte_devtype = u32;
#[doc = " Structure that stores a device given by the user with its arguments"]
#[doc = ""]
#[doc = " A user device is a physical or a virtual device given by the user to"]
#[doc = " the DPDK application at startup through command line arguments."]
#[doc = ""]
#[doc = " The structure stores the configuration of the device, its PCI"]
#[doc = " identifier if it's a PCI device or the driver name if it's a virtual"]
#[doc = " device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs {
    #[doc = " Next in list."]
    pub next: rte_devargs__bindgen_ty_1,
    #[doc = " Type of device."]
    pub type_: rte_devtype,
    #[doc = " Device policy."]
    pub policy: rte_dev_policy,
    #[doc = " Bus handle for the device."]
    pub bus: *mut rte_bus,
    #[doc = " Name of the device."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = " Arguments string as given by user or \"\" for no argument."]
    pub args: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_devargs__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_devargs() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs>(),
        72usize,
        concat!("Size of: ", stringify!(rte_devargs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).policy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).bus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs>())).args as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs),
            "::",
            stringify!(args)
        )
    );
}
#[doc = " user device double-linked queue type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs_list {
    pub tqh_first: *mut rte_devargs,
    pub tqh_last: *mut *mut rte_devargs,
}
#[test]
fn bindgen_test_layout_rte_devargs_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_devargs_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_devargs_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_devargs_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_devargs_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_devargs_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_devargs_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
extern "C" {
    pub static mut devargs_list: rte_devargs_list;
}
extern "C" {
    #[doc = " Parse a devargs string."]
    #[doc = ""]
    #[doc = " For PCI devices, the format of arguments string is \"PCI_ADDR\" or"]
    #[doc = " \"PCI_ADDR,key=val,key2=val2,...\". Examples: \"08:00.1\", \"0000:5:00.0\","]
    #[doc = " \"04:00.0,arg=val\"."]
    #[doc = ""]
    #[doc = " For virtual devices, the format of arguments string is \"DRIVER_NAME*\""]
    #[doc = " or \"DRIVER_NAME*,key=val,key2=val2,...\". Examples: \"net_ring\","]
    #[doc = " \"net_ring0\", \"net_pmdAnything,arg=0:arg2=1\"."]
    #[doc = ""]
    #[doc = " The function parses the arguments string to get driver name and driver"]
    #[doc = " arguments."]
    #[doc = ""]
    #[doc = " @param devargs_str"]
    #[doc = "   The arguments as given by the user."]
    #[doc = " @param drvname"]
    #[doc = "   The pointer to the string to store parsed driver name."]
    #[doc = " @param drvargs"]
    #[doc = "   The pointer to the string to store parsed driver arguments."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - A negative value on error"]
    pub fn rte_eal_parse_devargs_str(
        devargs_str: *const ::std::os::raw::c_char,
        drvname: *mut *mut ::std::os::raw::c_char,
        drvargs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a device string."]
    #[doc = ""]
    #[doc = " Verify that a bus is capable of handling the device passed"]
    #[doc = " in argument. Store which bus will handle the device, its name"]
    #[doc = " and the eventual device parameters."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   The device declaration string."]
    #[doc = " @param da"]
    #[doc = "   The devargs structure holding the device information."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative errno on error."]
    pub fn rte_eal_devargs_parse(
        dev: *const ::std::os::raw::c_char,
        da: *mut rte_devargs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert an rte_devargs in the global list."]
    #[doc = ""]
    #[doc = " @param da"]
    #[doc = "  The devargs structure to insert."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - Negative on error."]
    pub fn rte_eal_devargs_insert(da: *mut rte_devargs) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a device to the user device list"]
    #[doc = ""]
    #[doc = " For PCI devices, the format of arguments string is \"PCI_ADDR\" or"]
    #[doc = " \"PCI_ADDR,key=val,key2=val2,...\". Examples: \"08:00.1\", \"0000:5:00.0\","]
    #[doc = " \"04:00.0,arg=val\"."]
    #[doc = ""]
    #[doc = " For virtual devices, the format of arguments string is \"DRIVER_NAME*\""]
    #[doc = " or \"DRIVER_NAME*,key=val,key2=val2,...\". Examples: \"net_ring\","]
    #[doc = " \"net_ring0\", \"net_pmdAnything,arg=0:arg2=1\". The validity of the"]
    #[doc = " driver name is not checked by this function, it is done when probing"]
    #[doc = " the drivers."]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the device."]
    #[doc = " @param devargs_str"]
    #[doc = "   The arguments as given by the user."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - A negative value on error"]
    pub fn rte_eal_devargs_add(
        devtype: rte_devtype,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a device from the user device list."]
    #[doc = " Its resources are freed."]
    #[doc = " If the devargs cannot be found, nothing happens."]
    #[doc = ""]
    #[doc = " @param busname"]
    #[doc = "   bus name of the devargs to remove."]
    #[doc = ""]
    #[doc = " @param devname"]
    #[doc = "   device name of the devargs to remove."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success."]
    #[doc = "   <0 on error."]
    #[doc = "   >0 if the devargs was not within the user device list."]
    pub fn rte_eal_devargs_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the number of user devices of a specified type"]
    #[doc = ""]
    #[doc = " @param devtype"]
    #[doc = "   The type of the devices to counted."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of devices."]
    pub fn rte_eal_devargs_type_count(devtype: rte_devtype) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " This function dumps the list of user device and their arguments."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_eal_devargs_dump(f: *mut FILE);
}
extern "C" {
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function which returns a printable string describing a particular"]
    #[doc = " error code. For non-RTE-specific error codes, this function returns"]
    #[doc = " the value from the libc strerror function."]
    #[doc = ""]
    #[doc = " @param errnum"]
    #[doc = "   The error number to be looked up - generally the value of rte_errno"]
    #[doc = " @return"]
    #[doc = "   A pointer to a thread-local string containing the text describing"]
    #[doc = "   the error."]
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = "< Start numbering above std errno vals"]
pub const RTE_MIN_ERRNO: _bindgen_ty_13 = 1000;
#[doc = "< Operation not allowed in secondary processes"]
pub const E_RTE_SECONDARY: _bindgen_ty_13 = 1001;
#[doc = "< Missing rte_config"]
pub const E_RTE_NO_CONFIG: _bindgen_ty_13 = 1002;
#[doc = "< Max RTE error number"]
pub const RTE_MAX_ERRNO: _bindgen_ty_13 = 1003;
#[doc = " Error types"]
pub type _bindgen_ty_13 = u32;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: __locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: __locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " 64 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64u8_t = [u8; 8usize];
#[doc = " 64 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u16_t){ a0, a1, a2, a3 }"]
pub type rte_v64u16_t = [u16; 4usize];
#[doc = " 64 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64u32_t){ a0, a1 }"]
pub type rte_v64u32_t = [u32; 2usize];
#[doc = " 128 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128u8_t = [u8; 16usize];
#[doc = " 128 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128u16_t = [u16; 8usize];
#[doc = " 128 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u32_t){ a0, a1, a2, a3, a4 }"]
pub type rte_v128u32_t = [u32; 4usize];
#[doc = " 128 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128u64_t){ a0, a1 }"]
pub type rte_v128u64_t = [u64; 2usize];
#[doc = " 256 bits vector size to use with unsigned 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256u8_t = [u8; 32usize];
#[doc = " 256 bits vector size to use with unsigned 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256u16_t = [u16; 16usize];
#[doc = " 256 bits vector size to use with unsigned 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256u32_t = [u32; 8usize];
#[doc = " 256 bits vector size to use with unsigned 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256u64_t){ a0, a1, a2, a3 }"]
pub type rte_v256u64_t = [u64; 4usize];
#[doc = " 64 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s8_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v64s8_t = [i8; 8usize];
#[doc = " 64 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s16_t){ a0, a1, a2, a3 }"]
pub type rte_v64s16_t = [i16; 4usize];
#[doc = " 64 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v64s32_t){ a0, a1 }"]
pub type rte_v64s32_t = [i32; 2usize];
#[doc = " 128 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v128s8_t = [i8; 16usize];
#[doc = " 128 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s16_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v128s16_t = [i16; 8usize];
#[doc = " 128 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s32_t){ a0, a1, a2, a3 }"]
pub type rte_v128s32_t = [i32; 4usize];
#[doc = " 128 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v128s64_t){ a1, a2 }"]
pub type rte_v128s64_t = [i64; 2usize];
#[doc = " 256 bits vector size to use with 8 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s8_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                     a08, a09, a10, a11, a12, a13, a14, a15,"]
#[doc = "                     a16, a17, a18, a19, a20, a21, a22, a23,"]
#[doc = "                     a24, a25, a26, a27, a28, a29, a30, a31 }"]
pub type rte_v256s8_t = [i8; 32usize];
#[doc = " 256 bits vector size to use with 16 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s16_t){ a00, a01, a02, a03, a04, a05, a06, a07,"]
#[doc = "                      a08, a09, a10, a11, a12, a13, a14, a15 }"]
pub type rte_v256s16_t = [i16; 16usize];
#[doc = " 256 bits vector size to use with 32 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s32_t){ a0, a1, a2, a3, a4, a5, a6, a7 }"]
pub type rte_v256s32_t = [i32; 8usize];
#[doc = " 256 bits vector size to use with 64 bits elements."]
#[doc = ""]
#[doc = " a = (rte_v256s64_t){ a0, a1, a2, a3 }"]
pub type rte_v256s64_t = [i64; 4usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8: [u8; 16usize],
    pub u16: [u16; 8usize],
    pub u32: [u32; 4usize],
    pub u64: [u64; 2usize],
    pub pd: [f64; 2usize],
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    assert_eq!(
        ::std::mem::size_of::<rte_xmm>(),
        16usize,
        concat!("Size of: ", stringify!(rte_xmm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_xmm>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_xmm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_xmm>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(pd)
        )
    );
}
pub type rte_xmm_t = rte_xmm;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = "< waiting a new command"]
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
#[doc = "< executing command"]
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
#[doc = "< command executed"]
pub const rte_lcore_state_t_FINISHED: rte_lcore_state_t = 2;
#[doc = " State of an lcore."]
pub type rte_lcore_state_t = u32;
#[doc = " Definition of a remote launch function."]
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Launch a function on another lcore."]
    #[doc = ""]
    #[doc = " To be executed on the MASTER lcore only."]
    #[doc = ""]
    #[doc = " Sends a message to a slave lcore (identified by the slave_id) that"]
    #[doc = " is in the WAIT state (this is true after the first call to"]
    #[doc = " rte_eal_init()). This can be checked by first calling"]
    #[doc = " rte_eal_wait_lcore(slave_id)."]
    #[doc = ""]
    #[doc = " When the remote lcore receives the message, it switches to"]
    #[doc = " the RUNNING state, then calls the function f with argument arg. Once the"]
    #[doc = " execution is done, the remote lcore switches to a FINISHED state and"]
    #[doc = " the return value of f is stored in a local variable to be read using"]
    #[doc = " rte_eal_wait_lcore()."]
    #[doc = ""]
    #[doc = " The MASTER lcore returns as soon as the message is sent and knows"]
    #[doc = " nothing about the completion of f."]
    #[doc = ""]
    #[doc = " Note: This function is not designed to offer optimum"]
    #[doc = " performance. It is just a practical way to launch a function on"]
    #[doc = " another lcore at initialization time."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param slave_id"]
    #[doc = "   The identifier of the lcore on which the function should be executed."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on the remote lcore."]
    #[doc = "   - (-EBUSY): The remote lcore is not in a WAIT state."]
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        slave_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< lcore handler not executed by master core."]
pub const rte_rmt_call_master_t_SKIP_MASTER: rte_rmt_call_master_t = 0;
#[doc = "< lcore handler executed by master core."]
pub const rte_rmt_call_master_t_CALL_MASTER: rte_rmt_call_master_t = 1;
#[doc = " This enum indicates whether the master core must execute the handler"]
#[doc = " launched on all logical cores."]
pub type rte_rmt_call_master_t = u32;
extern "C" {
    #[doc = " Launch a function on all lcores."]
    #[doc = ""]
    #[doc = " Check that each SLAVE lcore is in a WAIT state, then call"]
    #[doc = " rte_eal_remote_launch() for each lcore."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   The function to be called."]
    #[doc = " @param arg"]
    #[doc = "   The argument for the function."]
    #[doc = " @param call_master"]
    #[doc = "   If call_master set to SKIP_MASTER, the MASTER lcore does not call"]
    #[doc = "   the function. If call_master is set to CALL_MASTER, the function"]
    #[doc = "   is also called on master before returning. In any case, the master"]
    #[doc = "   lcore returns as soon as it finished its job and knows nothing"]
    #[doc = "   about the completion of f on the other lcores."]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Execution of function f started on all remote lcores."]
    #[doc = "   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this"]
    #[doc = "     case, no message is sent to any of the lcores."]
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_master: rte_rmt_call_master_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the state of the lcore identified by slave_id."]
    #[doc = ""]
    #[doc = " To be executed on the MASTER lcore only."]
    #[doc = ""]
    #[doc = " @param slave_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   The state of the lcore."]
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
extern "C" {
    #[doc = " Wait until an lcore finishes its job."]
    #[doc = ""]
    #[doc = " To be executed on the MASTER lcore only."]
    #[doc = ""]
    #[doc = " If the slave lcore identified by the slave_id is in a FINISHED state,"]
    #[doc = " switch to the WAIT state. If the lcore is in RUNNING state, wait until"]
    #[doc = " the lcore finishes its job and moves to the FINISHED state."]
    #[doc = ""]
    #[doc = " @param slave_id"]
    #[doc = "   The identifier of the lcore."]
    #[doc = " @return"]
    #[doc = "   - 0: If the lcore identified by the slave_id is in a WAIT state."]
    #[doc = "   - The value that was returned by the previous remote launch"]
    #[doc = "     function call if the lcore identified by the slave_id was in a"]
    #[doc = "     FINISHED or RUNNING state. In this case, it changes the state"]
    #[doc = "     of the lcore to WAIT."]
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait until all lcores finish their jobs."]
    #[doc = ""]
    #[doc = " To be executed on the MASTER lcore only. Issue an"]
    #[doc = " rte_eal_wait_lcore() for every lcore. The return values are"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " After a call to rte_eal_mp_wait_lcore(), the caller can assume"]
    #[doc = " that all slave lcores are in a WAIT state."]
    pub fn rte_eal_mp_wait_lcore();
}
pub type rte_cpuset_t = cpu_set_t;
#[doc = " Structure storing internal configuration (per-lcore)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcore_config {
    #[doc = "< true if lcore was detected"]
    pub detected: ::std::os::raw::c_uint,
    #[doc = "< pthread identifier"]
    pub thread_id: pthread_t,
    #[doc = "< communication pipe with master"]
    pub pipe_master2slave: [::std::os::raw::c_int; 2usize],
    #[doc = "< communication pipe with master"]
    pub pipe_slave2master: [::std::os::raw::c_int; 2usize],
    #[doc = "< function to call"]
    pub f: lcore_function_t,
    #[doc = "< argument of function"]
    pub arg: *mut ::std::os::raw::c_void,
    #[doc = "< return value of function"]
    pub ret: ::std::os::raw::c_int,
    #[doc = "< lcore state"]
    pub state: rte_lcore_state_t,
    #[doc = "< physical socket id for this lcore"]
    pub socket_id: ::std::os::raw::c_uint,
    #[doc = "< core number on socket for this lcore"]
    pub core_id: ::std::os::raw::c_uint,
    #[doc = "< relative index, starting from 0"]
    pub core_index: ::std::os::raw::c_int,
    #[doc = "< cpu set which the lcore affinity to"]
    pub cpuset: rte_cpuset_t,
    #[doc = "< role of core eg: OFF, RTE, SERVICE"]
    pub core_role: u8,
}
#[test]
fn bindgen_test_layout_lcore_config() {
    assert_eq!(
        ::std::mem::size_of::<lcore_config>(),
        208usize,
        concat!("Size of: ", stringify!(lcore_config))
    );
    assert_eq!(
        ::std::mem::align_of::<lcore_config>(),
        8usize,
        concat!("Alignment of ", stringify!(lcore_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).detected as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(detected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).thread_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).pipe_master2slave as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(pipe_master2slave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).pipe_slave2master as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(pipe_slave2master)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).f as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).arg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).ret as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(ret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).socket_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_index as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).cpuset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lcore_config>())).core_role as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(lcore_config),
            "::",
            stringify!(core_role)
        )
    );
}
extern "C" {
    pub static mut lcore_config: [lcore_config; 128usize];
}
extern "C" {
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut per_lcore__cpuset: cpu_set_t;
}
extern "C" {
    #[doc = " Return the ID of the physical socket of the logical core we are"]
    #[doc = " running on."]
    #[doc = " @return"]
    #[doc = "   the ID of current lcoreid's physical socket"]
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Set core affinity of the current thread."]
    #[doc = " Support both EAL and non-EAL thread and update TLS."]
    #[doc = ""]
    #[doc = " @param cpusetp"]
    #[doc = "   Point to cpu_set_t for setting current thread affinity."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return -1;"]
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get core affinity of the current thread."]
    #[doc = ""]
    #[doc = " @param cpusetp"]
    #[doc = "   Point to cpu_set_t for getting current thread cpu affinity."]
    #[doc = "   It presumes input is not NULL, otherwise it causes panic."]
    #[doc = ""]
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    #[doc = " Set thread names."]
    #[doc = ""]
    #[doc = " @note It fails with glibc < 2.12."]
    #[doc = ""]
    #[doc = " @param id"]
    #[doc = "   Thread id."]
    #[doc = " @param name"]
    #[doc = "   Thread name to set."]
    #[doc = " @return"]
    #[doc = "   On success, return 0; otherwise return a negative value."]
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The rte_spinlock_t type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_t {
    #[doc = "< lock status 0 = unlocked, 1 = locked"]
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_t>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
#[doc = " The rte_spinlock_recursive_t type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    #[doc = "< the actual spinlock"]
    pub sl: rte_spinlock_t,
    #[doc = "< core id using lock, -1 for unused"]
    pub user: ::std::os::raw::c_int,
    #[doc = "< count of time this lock has been called"]
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).user as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
#[doc = "< SSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
#[doc = "< PCLMULQDQ"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
#[doc = "< DTES64"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
#[doc = "< MONITOR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
#[doc = "< DS_CPL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
#[doc = "< VMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
#[doc = "< SMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
#[doc = "< EIST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
#[doc = "< TM2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
#[doc = "< SSSE3"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
#[doc = "< CNXT_ID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
#[doc = "< FMA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
#[doc = "< CMPXCHG16B"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
#[doc = "< XTPR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
#[doc = "< PDCM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
#[doc = "< PCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
#[doc = "< DCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
#[doc = "< SSE4_1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
#[doc = "< SSE4_2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
#[doc = "< X2APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
#[doc = "< MOVBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
#[doc = "< POPCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
#[doc = "< TSC_DEADLINE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
#[doc = "< AES"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
#[doc = "< XSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
#[doc = "< OSXSAVE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
#[doc = "< AVX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
#[doc = "< F16C"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
#[doc = "< RDRAND"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
#[doc = "< FPU"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 29;
#[doc = "< VME"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 30;
#[doc = "< DE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 31;
#[doc = "< PSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 32;
#[doc = "< TSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 33;
#[doc = "< MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 34;
#[doc = "< PAE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 35;
#[doc = "< MCE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 36;
#[doc = "< CX8"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 37;
#[doc = "< APIC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 38;
#[doc = "< SEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 39;
#[doc = "< MTRR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 40;
#[doc = "< PGE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 41;
#[doc = "< MCA"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 42;
#[doc = "< CMOV"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 43;
#[doc = "< PAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 44;
#[doc = "< PSE36"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 45;
#[doc = "< PSN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 46;
#[doc = "< CLFSH"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 47;
#[doc = "< DS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 48;
#[doc = "< ACPI"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 49;
#[doc = "< MMX"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 50;
#[doc = "< FXSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 51;
#[doc = "< SSE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 52;
#[doc = "< SSE2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 53;
#[doc = "< SS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 54;
#[doc = "< HTT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 55;
#[doc = "< TM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 56;
#[doc = "< PBE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 57;
#[doc = "< DIGTEMP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 58;
#[doc = "< TRBOBST"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 59;
#[doc = "< ARAT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 60;
#[doc = "< PLN"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 61;
#[doc = "< ECMD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 62;
#[doc = "< PTM"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 63;
#[doc = "< MPERF_APERF_MSR"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 64;
#[doc = "< ACNT2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 65;
#[doc = "< ENERGY_EFF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 66;
#[doc = "< FSGSBASE"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 67;
#[doc = "< BMI1"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 68;
#[doc = "< Hardware Lock elision"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 69;
#[doc = "< AVX2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 70;
#[doc = "< SMEP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 71;
#[doc = "< BMI2"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 72;
#[doc = "< ERMS"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 73;
#[doc = "< INVPCID"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 74;
#[doc = "< Transactional memory"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 75;
#[doc = "< AVX512F"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 76;
#[doc = "< LAHF_SAHF"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 77;
#[doc = "< LZCNT"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 78;
#[doc = "< SYSCALL"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 79;
#[doc = "< XD"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 80;
#[doc = "< 1GB_PG"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 81;
#[doc = "< RDTSCP"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 82;
#[doc = "< EM64T"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 83;
#[doc = "< INVTSC"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 84;
#[doc = "< This should always be the last!"]
pub const rte_cpu_flag_t_RTE_CPUFLAG_NUMFLAGS: rte_cpu_flag_t = 85;
#[doc = " Enumeration of all CPU features supported"]
pub type rte_cpu_flag_t = u32;
extern "C" {
    #[doc = " Get name of CPU flag"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag ID"]
    #[doc = " @return"]
    #[doc = "     flag name"]
    #[doc = "     NULL if flag ID is invalid"]
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Function for checking a CPU flag availability"]
    #[doc = ""]
    #[doc = " @param feature"]
    #[doc = "     CPU flag to query CPU for"]
    #[doc = " @return"]
    #[doc = "     1 if flag is available"]
    #[doc = "     0 if flag is not available"]
    #[doc = "     -ENOENT if flag is invalid"]
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features"]
    #[doc = " that were specified at compile time. It is called automatically within the"]
    #[doc = " EAL, so does not need to be used by applications."]
    pub fn rte_cpu_check_supported();
}
extern "C" {
    #[doc = " This function checks that the currently used CPU supports the CPU features"]
    #[doc = " that were specified at compile time. It is called automatically within the"]
    #[doc = " EAL, so does not need to be used by applications.  This version returns a"]
    #[doc = " result so that decisions may be made (for instance, graceful shutdowns)."]
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " A structure used to store memory information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_info {
    pub name: [::std::os::raw::c_char; 256usize],
    pub size: u64,
}
#[test]
fn bindgen_test_layout_memory_info() {
    assert_eq!(
        ::std::mem::size_of::<memory_info>(),
        264usize,
        concat!("Size of: ", stringify!(memory_info))
    );
    assert_eq!(
        ::std::mem::align_of::<memory_info>(),
        8usize,
        concat!("Alignment of ", stringify!(memory_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memory_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memory_info>())).size as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(memory_info),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " A structure used to store memory segment information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memseg_info {
    pub idx: u32,
    pub pfn: u64,
    pub size: u64,
    pub mfn: [u64; 2048usize],
}
#[test]
fn bindgen_test_layout_memseg_info() {
    assert_eq!(
        ::std::mem::size_of::<memseg_info>(),
        16408usize,
        concat!("Size of: ", stringify!(memseg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<memseg_info>(),
        8usize,
        concat!("Alignment of ", stringify!(memseg_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memseg_info>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memseg_info),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memseg_info>())).pfn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memseg_info),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memseg_info>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memseg_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memseg_info>())).mfn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memseg_info),
            "::",
            stringify!(mfn)
        )
    );
}
#[doc = " A structure used to store memory block information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memblock_info {
    pub exchange_flag: u8,
    pub used: u8,
    pub vir_addr: u64,
    pub pfn: u64,
    pub mfn: u64,
}
#[test]
fn bindgen_test_layout_memblock_info() {
    assert_eq!(
        ::std::mem::size_of::<memblock_info>(),
        32usize,
        concat!("Size of: ", stringify!(memblock_info))
    );
    assert_eq!(
        ::std::mem::align_of::<memblock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(memblock_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memblock_info>())).exchange_flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memblock_info),
            "::",
            stringify!(exchange_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memblock_info>())).used as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(memblock_info),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memblock_info>())).vir_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(memblock_info),
            "::",
            stringify!(vir_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memblock_info>())).pfn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(memblock_info),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<memblock_info>())).mfn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(memblock_info),
            "::",
            stringify!(mfn)
        )
    );
}
pub const rte_page_sizes_RTE_PGSIZE_4K: rte_page_sizes = 4096;
pub const rte_page_sizes_RTE_PGSIZE_64K: rte_page_sizes = 65536;
pub const rte_page_sizes_RTE_PGSIZE_256K: rte_page_sizes = 262144;
pub const rte_page_sizes_RTE_PGSIZE_2M: rte_page_sizes = 2097152;
pub const rte_page_sizes_RTE_PGSIZE_16M: rte_page_sizes = 16777216;
pub const rte_page_sizes_RTE_PGSIZE_256M: rte_page_sizes = 268435456;
pub const rte_page_sizes_RTE_PGSIZE_512M: rte_page_sizes = 536870912;
pub const rte_page_sizes_RTE_PGSIZE_1G: rte_page_sizes = 1073741824;
pub const rte_page_sizes_RTE_PGSIZE_4G: rte_page_sizes = 4294967296;
pub const rte_page_sizes_RTE_PGSIZE_16G: rte_page_sizes = 17179869184;
pub type rte_page_sizes = u64;
pub type phys_addr_t = u64;
#[doc = " Physical memory segment descriptor."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    #[doc = "< Start physical address."]
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    #[doc = "< Length of the segment."]
    pub len: usize,
    #[doc = "< The pagesize of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Number of channels."]
    pub nchannel: u32,
    #[doc = "< Number of ranks."]
    pub nrank: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64 bits"]
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        44usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).hugepage_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).socket_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nchannel as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nrank as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nrank)
        )
    );
}
extern "C" {
    #[doc = " Lock page in physical memory and prevent from swapping."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error."]
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get physical address of any mapped virtual address in the current process."]
    #[doc = " It is found by browsing the /proc/self/pagemap special file."]
    #[doc = " The page must be locked."]
    #[doc = ""]
    #[doc = " @param virt"]
    #[doc = "   The virtual address."]
    #[doc = " @return"]
    #[doc = "   The physical address or RTE_BAD_PHYS_ADDR on error."]
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    #[doc = " Get the layout of the available physical memory."]
    #[doc = ""]
    #[doc = " It can be useful for an application to have the full physical"]
    #[doc = " memory layout to decide the size of a memory zone to reserve. This"]
    #[doc = " table is stored in rte_config (see rte_eal_get_configuration())."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return a pointer to a read-only table of struct"]
    #[doc = "    rte_physmem_desc elements, containing the layout of all"]
    #[doc = "    addressable physical memory. The last element of the table"]
    #[doc = "    contains a NULL address."]
    #[doc = "  - On error, return NULL. This should not happen since it is a fatal"]
    #[doc = "    error that will probably cause the entire system to panic."]
    pub fn rte_eal_get_physmem_layout() -> *const rte_memseg;
}
extern "C" {
    #[doc = " Dump the physical memory layout to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    #[doc = " Get the total amount of available physical memory."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    The total amount of available physical memory in bytes."]
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    #[doc = " Get the number of memory channels."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory channels on the system. The value is 0 if unknown"]
    #[doc = "   or not the same on all devices."]
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the number of memory ranks."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The number of memory ranks on the system. The value is 0 if unknown or"]
    #[doc = "   not the same on all devices."]
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
#[doc = " A structure describing a memzone, which is a contiguous portion of"]
#[doc = " physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start physical address."]
    pub phys_addr: phys_addr_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
    #[doc = "< Memseg it belongs."]
    pub memseg_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        76usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).phys_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).hugepage_sz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).socket_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).memseg_id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(memseg_id)
        )
    );
}
extern "C" {
    #[doc = " Reserve a portion of physical memory."]
    #[doc = ""]
    #[doc = " This function reserves some memory and returns a pointer to a"]
    #[doc = " correctly filled memzone descriptor. If the allocation cannot be"]
    #[doc = " done, return NULL."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with alignment on a specified"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with alignment on a specified"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " is not a power of 2, returns NULL."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Reserve a portion of physical memory with specified alignment and"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " This function reserves some memory with specified alignment and"]
    #[doc = " boundary, and returns a pointer to a correctly filled memzone"]
    #[doc = " descriptor. If the allocation cannot be done or if the alignment"]
    #[doc = " or boundary are not a power of 2, returns NULL."]
    #[doc = " Memory buffer is reserved in a way, that it wouldn't cross specified"]
    #[doc = " boundary. That implies that requested length should be less or equal"]
    #[doc = " then boundary."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone. If it already exists, the function will"]
    #[doc = "   fail and return NULL."]
    #[doc = " @param len"]
    #[doc = "   The size of the memory to be reserved. If it"]
    #[doc = "   is 0, the biggest contiguous zone will be reserved."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of"]
    #[doc = "   NUMA. The value can be SOCKET_ID_ANY if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The flags parameter is used to request memzones to be"]
    #[doc = "   taken from specifically sized hugepages."]
    #[doc = "   - RTE_MEMZONE_2MB - Reserved from 2MB pages"]
    #[doc = "   - RTE_MEMZONE_1GB - Reserved from 1GB pages"]
    #[doc = "   - RTE_MEMZONE_16MB - Reserved from 16MB pages"]
    #[doc = "   - RTE_MEMZONE_16GB - Reserved from 16GB pages"]
    #[doc = "   - RTE_MEMZONE_256KB - Reserved from 256KB pages"]
    #[doc = "   - RTE_MEMZONE_256MB - Reserved from 256MB pages"]
    #[doc = "   - RTE_MEMZONE_512MB - Reserved from 512MB pages"]
    #[doc = "   - RTE_MEMZONE_4GB - Reserved from 4GB pages"]
    #[doc = "   - RTE_MEMZONE_SIZE_HINT_ONLY - Allow alternative page size to be used if"]
    #[doc = "                                  the requested page size is unavailable."]
    #[doc = "                                  If this flag is not set, the function"]
    #[doc = "                                  will return error on an unavailable size"]
    #[doc = "                                  request."]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @param bound"]
    #[doc = "   Boundary for resulting memzone. Must be a power of 2 or zero."]
    #[doc = "   Zero value implies no boundary condition."]
    #[doc = " @return"]
    #[doc = "   A pointer to a correctly-filled read-only memzone descriptor, or NULL"]
    #[doc = "   on error."]
    #[doc = "   On error case, rte_errno will be set appropriately:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    #[doc = "    - EINVAL - invalid parameters"]
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Free a memzone."]
    #[doc = ""]
    #[doc = " @param mz"]
    #[doc = "   A pointer to the memzone"]
    #[doc = " @return"]
    #[doc = "  -EINVAL - invalid parameter."]
    #[doc = "  0 - success"]
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lookup for a memzone."]
    #[doc = ""]
    #[doc = " Get a pointer to a descriptor of an already reserved memory"]
    #[doc = " zone identified by the name given as an argument."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the memzone."]
    #[doc = " @return"]
    #[doc = "   A pointer to a read-only memzone descriptor."]
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Dump all reserved memzones to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Walk list of all memzones"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
pub type rte_ring_queue_behavior = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring_headtail {
    #[doc = "< Prod/consumer head."]
    pub head: u32,
    #[doc = "< Prod/consumer tail."]
    pub tail: u32,
    #[doc = "< True if single prod/cons"]
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).single as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(single)
        )
    );
}
#[doc = " An RTE ring structure."]
#[doc = ""]
#[doc = " The producer and the consumer have a head and a tail index. The particularity"]
#[doc = " of these index is that they are not between 0 and size(ring). These indexes"]
#[doc = " are between 0 and 2^32, and we mask their value when we access the ring[]"]
#[doc = " field. Thanks to this assumption, we can do subtractions between 2 index"]
#[doc = " values in a modulo-32bit base: that's why the overflow of the indexes is not"]
#[doc = " a problem."]
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    #[doc = "< Name of the ring."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Flags supplied at creation."]
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    #[doc = "< Size of ring."]
    pub size: u32,
    #[doc = "< Mask (size-1) of ring."]
    pub mask: u32,
    #[doc = "< Usable size of ring"]
    pub capacity: u32,
    pub __bindgen_padding_0: [u32; 17usize],
    #[doc = " Ring producer status."]
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_1: [u32; 29usize],
    #[doc = " Ring consumer status."]
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_2: [u32; 29usize],
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring>(),
        128usize,
        concat!("Alignment of ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).memzone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(memzone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).capacity as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).prod as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).cons as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cons)
        )
    );
}
extern "C" {
    #[doc = " Calculate the memory size needed for a ring"]
    #[doc = ""]
    #[doc = " This function returns the number of bytes needed for a ring, given"]
    #[doc = " the number of elements in it. This value is the sum of the size of"]
    #[doc = " the structure rte_ring and the size of the memory needed by the"]
    #[doc = " objects pointers. The value is aligned to a cache line size."]
    #[doc = ""]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @return"]
    #[doc = "   - The memory size needed for the ring on success."]
    #[doc = "   - -EINVAL if count is not a power of 2."]
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    #[doc = " Initialize a ring structure."]
    #[doc = ""]
    #[doc = " Initialize a ring structure in memory pointed by \"r\". The size of the"]
    #[doc = " memory area must be large enough to store the ring structure and the"]
    #[doc = " object table. It is advised to use rte_ring_get_memsize() to get the"]
    #[doc = " appropriate size."]
    #[doc = ""]
    #[doc = " The ring size is set to *count*, which must be a power of two. Water"]
    #[doc = " marking is disabled by default. The real usable ring size is"]
    #[doc = " *count-1* instead of *count* to differentiate a free ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is not added in RTE_TAILQ_RING global list. Indeed, the"]
    #[doc = " memory given by the caller may not be shareable among dpdk"]
    #[doc = " processes."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   The pointer to the ring structure followed by the objects table."]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The number of elements in the ring (must be a power of 2)."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "    - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "      is \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "    - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "      is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = " @return"]
    #[doc = "   0 on success, or a negative value on error."]
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new ring named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``memzone_reserve()`` to allocate memory. Then it"]
    #[doc = " calls rte_ring_init() to initialize an empty ring."]
    #[doc = ""]
    #[doc = " The new ring size is set to *count*, which must be a power of"]
    #[doc = " two. Water marking is disabled by default. The real usable ring size"]
    #[doc = " is *count-1* instead of *count* to differentiate a free ring from an"]
    #[doc = " empty ring."]
    #[doc = ""]
    #[doc = " The ring is added in RTE_TAILQ_RING list."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @param count"]
    #[doc = "   The size of the ring (must be a power of 2)."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   An OR of the following:"]
    #[doc = "    - RING_F_SP_ENQ: If this flag is set, the default behavior when"]
    #[doc = "      using ``rte_ring_enqueue()`` or ``rte_ring_enqueue_bulk()``"]
    #[doc = "      is \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "    - RING_F_SC_DEQ: If this flag is set, the default behavior when"]
    #[doc = "      using ``rte_ring_dequeue()`` or ``rte_ring_dequeue_bulk()``"]
    #[doc = "      is \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = " @return"]
    #[doc = "   On success, the pointer to the new allocated ring. NULL on error with"]
    #[doc = "    rte_errno set appropriately. Possible errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - count provided is not a power of 2"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    #[doc = " De-allocate all memory used by the ring."]
    #[doc = ""]
    #[doc = " @param r"]
    #[doc = "   Ring to free"]
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    #[doc = " Dump the status of the ring to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param r"]
    #[doc = "   A pointer to the ring structure."]
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    #[doc = " Dump the status of all rings on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a ring from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the ring."]
    #[doc = " @return"]
    #[doc = "   The pointer to the ring matching the name, or NULL if not found,"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    #[doc = "< Cache objects"]
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
    pub __bindgen_padding_0: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        12352usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).flushthresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).objs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).elt_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).trailer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).total_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
#[doc = " Mempool object header structure"]
#[doc = ""]
#[doc = " Each object stored in mempools are prefixed by this header structure,"]
#[doc = " it allows to retrieve the mempool pointer from the object and to"]
#[doc = " iterate on all objects attached to a mempool. When debug is enabled,"]
#[doc = " a cookie is also added in this structure preventing corruptions and"]
#[doc = " double-frees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< Physical address of the object."]
    pub physaddr: phys_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).physaddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(physaddr)
        )
    );
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure"]
#[doc = ""]
#[doc = " The memory chunks where objects are stored. Each chunk is virtually"]
#[doc = " and physically contiguous."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Physical address of the chunk"]
    pub phys_addr: phys_addr_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).phys_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).free_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_int,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops"]
    #[doc = " structs, which contain callback function pointers."]
    #[doc = " We're using an index here rather than pointers to the callbacks"]
    #[doc = " to facilitate any secondary processes that may want to use"]
    #[doc = " this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
    pub __bindgen_padding_0: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).pool_config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).socket_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).cache_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).header_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).trailer_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).private_data_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).ops_index as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).local_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).populated_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).nb_mem_chunks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mem_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @internal Check and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   Index of object in object table."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
#[doc = " Prototype for implementation specific data provisioning function."]
#[doc = ""]
#[doc = " The function should provide the implementation specific memory for"]
#[doc = " use by the other mempool ops functions in a given mempool ops struct."]
#[doc = " E.g. the default ops provides an instance of the rte_ring for this purpose."]
#[doc = " it will most likely point to a different type of data structure, and"]
#[doc = " will be transparent to the application programmer."]
#[doc = " This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue an object into the external pool."]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an object from the external pool."]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    pub __bindgen_padding_0: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).enqueue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
}
#[doc = " Structure storing the table of registered ops structs, each of which contain"]
#[doc = " the function pointers for the mempool ops functions."]
#[doc = " Each process has its own storage for this ops struct array so that"]
#[doc = " the mempools can be shared across primary and secondary processes."]
#[doc = " The indices used to access the array are valid across processes, whereas"]
#[doc = " any function pointers stored directly in the mempool struct would not be."]
#[doc = " This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops_table>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).num_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    #[doc = " @internal Wrapper for mempool_ops alloc callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; successfully allocated mempool pool_data."]
    #[doc = "   - <0: Error; code of alloc function."]
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops get_count callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   The number of available objects in the external pool."]
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops free callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Set the ops of a mempool."]
    #[doc = ""]
    #[doc = " This can only be done on a mempool that is not populated, i.e. just after"]
    #[doc = " a call to rte_mempool_create_empty()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param name"]
    #[doc = "   Name of the ops structure to use for this mempool."]
    #[doc = " @param pool_config"]
    #[doc = "   Opaque data that can be passed by the application to the ops functions."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the mempool is now using the requested ops functions."]
    #[doc = "   - -EINVAL - Invalid ops struct name provided."]
    #[doc = "   - -EEXIST - mempool already has an ops struct assigned."]
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mempool operations."]
    #[doc = ""]
    #[doc = " @param ops"]
    #[doc = "   Pointer to an ops structure to register."]
    #[doc = " @return"]
    #[doc = "   - >=0: Success; return the index of the ops struct in the table."]
    #[doc = "   - -EINVAL - some missing callbacks while registering ops struct."]
    #[doc = "   - -ENOSPC - the maximum number of ops structs has been reached."]
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
#[doc = " An object callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function."]
#[doc = ""]
#[doc = " Arguments are the mempool and the opaque pointer given by the user in"]
#[doc = " rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Create a new mempool named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``rte_memzone_reserve()`` to allocate memory. The"]
    #[doc = " pool contains n elements of elt_size. Its size is set to n."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mempool. The optimum size (in terms of"]
    #[doc = "   memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   If cache_size is non-zero, the rte_mempool library will try to"]
    #[doc = "   limit the accesses to the common lockless pool, by maintaining a"]
    #[doc = "   per-lcore object cache. This argument must be lower or equal to"]
    #[doc = "   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose"]
    #[doc = "   cache_size to have \"n modulo cache_size == 0\": if this is"]
    #[doc = "   not the case, some elements will always stay in the pool and will"]
    #[doc = "   never be used. The access to the per-lcore table is of course"]
    #[doc = "   faster than the multi-producer/consumer pool. The cache can be"]
    #[doc = "   disabled if the cache_size argument is set to 0; it can be useful to"]
    #[doc = "   avoid losing objects in cache."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param mp_init"]
    #[doc = "   A function pointer that is called for initialization of the pool,"]
    #[doc = "   before object initialization. The user can initialize the private"]
    #[doc = "   data in this function if needed. This parameter can be NULL if"]
    #[doc = "   not needed."]
    #[doc = " @param mp_init_arg"]
    #[doc = "   An opaque pointer to data that can be used in the mempool"]
    #[doc = "   constructor function."]
    #[doc = " @param obj_init"]
    #[doc = "   A function pointer that is called for each object at"]
    #[doc = "   initialization of the pool. The user can set some meta data in"]
    #[doc = "   objects if needed. This parameter can be NULL if not needed."]
    #[doc = "   The obj_init() function takes the mempool pointer, the init_arg,"]
    #[doc = "   the object pointer and the object number as parameters."]
    #[doc = " @param obj_init_arg"]
    #[doc = "   An opaque pointer to data that can be used as an argument for"]
    #[doc = "   each call to the object constructor function."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The *flags* arguments is an OR of following flags:"]
    #[doc = "   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread"]
    #[doc = "     between channels in RAM: the pool allocator will add padding"]
    #[doc = "     between objects depending on the hardware configuration. See"]
    #[doc = "     Memory alignment constraints for details. If this flag is set,"]
    #[doc = "     the allocator will just align them to a cache line."]
    #[doc = "   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are"]
    #[doc = "     cache-aligned. This flag removes this constraint, and no"]
    #[doc = "     padding will be present between objects. This flag implies"]
    #[doc = "     MEMPOOL_F_NO_SPREAD."]
    #[doc = "   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_put() or rte_mempool_put_bulk() is"]
    #[doc = "     \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_get() or rte_mempool_get_bulk() is"]
    #[doc = "     \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "   - MEMPOOL_F_NO_PHYS_CONTIG: If set, allocated objects won't"]
    #[doc = "     necessarily be contiguous in physical memory."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create a new mempool named *name* in memory."]
    #[doc = ""]
    #[doc = " The pool contains n elements of elt_size. Its size is set to n."]
    #[doc = " This function uses ``memzone_reserve()`` to allocate the mempool header"]
    #[doc = " (and the objects if vaddr is NULL)."]
    #[doc = " Depending on the input parameters, mempool elements can be either allocated"]
    #[doc = " together with the mempool header, or an externally provided memory buffer"]
    #[doc = " could be used to store mempool objects. In later case, that external"]
    #[doc = " memory buffer can consist of set of disjoint physical pages."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mempool. The optimum size (in terms of"]
    #[doc = "   memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the cache. See rte_mempool_create() for details."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param mp_init"]
    #[doc = "   A function pointer that is called for initialization of the pool,"]
    #[doc = "   before object initialization. The user can initialize the private"]
    #[doc = "   data in this function if needed. This parameter can be NULL if"]
    #[doc = "   not needed."]
    #[doc = " @param mp_init_arg"]
    #[doc = "   An opaque pointer to data that can be used in the mempool"]
    #[doc = "   constructor function."]
    #[doc = " @param obj_init"]
    #[doc = "   A function called for each object at initialization of the pool."]
    #[doc = "   See rte_mempool_create() for details."]
    #[doc = " @param obj_init_arg"]
    #[doc = "   An opaque pointer passed to the object constructor function."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   Flags controlling the behavior of the mempool. See"]
    #[doc = "   rte_mempool_create() for details."]
    #[doc = " @param vaddr"]
    #[doc = "   Virtual address of the externally allocated memory buffer."]
    #[doc = "   Will be used to store mempool objects."]
    #[doc = " @param paddr"]
    #[doc = "   Array of physical addresses of the pages that comprises given memory"]
    #[doc = "   buffer."]
    #[doc = " @param pg_num"]
    #[doc = "   Number of elements in the paddr array."]
    #[doc = " @param pg_shift"]
    #[doc = "   LOG2 of the physical pages size."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_xmem_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        paddr: *const phys_addr_t,
        pg_num: u32,
        pg_shift: u32,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create an empty mempool"]
    #[doc = ""]
    #[doc = " The mempool is allocated and initialized, but it is not populated: no"]
    #[doc = " memory is allocated for the mempool elements. The user has to call"]
    #[doc = " rte_mempool_populate_*() to add memory chunks to the pool. Once"]
    #[doc = " populated, the user may also want to initialize each object with"]
    #[doc = " rte_mempool_obj_iter()."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The maximum number of elements that can be added in the mempool."]
    #[doc = "   The optimum size (in terms of memory usage) for a mempool is when n"]
    #[doc = "   is a power of two minus one: n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the cache. See rte_mempool_create() for details."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   Flags controlling the behavior of the mempool. See"]
    #[doc = "   rte_mempool_create() for details."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a mempool"]
    #[doc = ""]
    #[doc = " Unlink the mempool from global list, free the memory chunks, and all"]
    #[doc = " memory referenced by the mempool. The objects must not be used by"]
    #[doc = " other cores as they will be freed."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Add physically contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually and physically contiguous memory chunk in the pool"]
    #[doc = " where objects can be instantiated."]
    #[doc = ""]
    #[doc = " If the given physical address is unknown (paddr = RTE_BAD_PHYS_ADDR),"]
    #[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
    #[doc = " and allocated objects may span two pages."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param paddr"]
    #[doc = "   The physical address"]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_phys(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        paddr: phys_addr_t,
        len: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add physical memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually contiguous memory chunk in the pool where objects can"]
    #[doc = " be instantiated. The physical addresses corresponding to the virtual"]
    #[doc = " area are described in paddr[], pg_num, pg_shift."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param paddr"]
    #[doc = "   An array of physical addresses of each page composing the virtual"]
    #[doc = "   area."]
    #[doc = " @param pg_num"]
    #[doc = "   Number of elements in the paddr array."]
    #[doc = " @param pg_shift"]
    #[doc = "   LOG2 of the physical pages size."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunks are not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_phys_tab(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        paddr: *const phys_addr_t,
        pg_num: u32,
        pg_shift: u32,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add virtually contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually contiguous memory chunk in the pool where objects can"]
    #[doc = " be instantiated."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param addr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = "   Must be page-aligned."]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes. Must be page-aligned."]
    #[doc = " @param pg_sz"]
    #[doc = "   The size of memory pages in this virtual area."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: usize,
        pg_sz: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This is the default function used by rte_mempool_create() to populate"]
    #[doc = " the mempool. It adds memory allocated using rte_memzone_reserve()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory from anonymous mapping for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This function mmap an anonymous memory zone that is locked in"]
    #[doc = " memory to store the objects of the mempool."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a function for each mempool element"]
    #[doc = ""]
    #[doc = " Iterate across all objects attached to a rte_mempool and call the"]
    #[doc = " callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param obj_cb"]
    #[doc = "   A function pointer that is called for each object."]
    #[doc = " @param obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of objects iterated."]
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Call a function for each mempool memory chunk"]
    #[doc = ""]
    #[doc = " Iterate across all memory chunks attached to a rte_mempool and call"]
    #[doc = " the callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param mem_cb"]
    #[doc = "   A function pointer that is called for each memory chunk."]
    #[doc = " @param mem_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of memory chunks iterated."]
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Dump the status of the mempool to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Create a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " This can be used by non-EAL threads to enable caching when they"]
    #[doc = " interact with a mempool."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "   The size of the mempool cache. See rte_mempool_create()'s cache_size"]
    #[doc = "   parameter description for more information. The same limits and"]
    #[doc = "   considerations apply here too."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of NUMA. The value can be"]
    #[doc = "   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone."]
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    #[doc = " Free a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " @param cache"]
    #[doc = "   A pointer to the mempool cache."]
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    #[doc = " Return the number of entries in the mempool."]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes. User-owned mempool caches are not accounted for."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of elements which have been allocated from the mempool"]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of free entries in the mempool."]
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check the consistency of mempool objects."]
    #[doc = ""]
    #[doc = " Verify the coherency of fields in the mempool structure. Also check"]
    #[doc = " that the cookies of mempool objects (even the ones that are not"]
    #[doc = " present in pool) have a correct value. If not, a panic will occur."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Dump the status of all mempools on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a mempool from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the mempool matching the name, or NULL if not found."]
    #[doc = "   NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    #[doc = ""]
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Get the header, trailer and total size of a mempool element."]
    #[doc = ""]
    #[doc = " Given a desired size of the mempool element and mempool flags,"]
    #[doc = " calculates header, trailer, body and total sizes of the mempool object."]
    #[doc = ""]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element, without header and trailer."]
    #[doc = " @param flags"]
    #[doc = "   The flags used for the mempool creation."]
    #[doc = "   Consult rte_mempool_create() for more information about possible values."]
    #[doc = "   The size of each element."]
    #[doc = " @param sz"]
    #[doc = "   The calculated detailed size the mempool object. May be NULL."]
    #[doc = " @return"]
    #[doc = "   Total size of the mempool object."]
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    #[doc = " Get the size of memory required to store mempool elements."]
    #[doc = ""]
    #[doc = " Calculate the maximum amount of memory required to store given number"]
    #[doc = " of objects. Assume that the memory buffer will be aligned at page"]
    #[doc = " boundary."]
    #[doc = ""]
    #[doc = " Note that if object size is bigger then page size, then it assumes"]
    #[doc = " that pages are grouped in subsets of physically continuous pages big"]
    #[doc = " enough to store at least one object."]
    #[doc = ""]
    #[doc = " @param elt_num"]
    #[doc = "   Number of elements."]
    #[doc = " @param total_elt_sz"]
    #[doc = "   The size of each element, including header and trailer, as returned"]
    #[doc = "   by rte_mempool_calc_obj_size()."]
    #[doc = " @param pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @return"]
    #[doc = "   Required memory size aligned at page boundary."]
    pub fn rte_mempool_xmem_size(elt_num: u32, total_elt_sz: usize, pg_shift: u32) -> usize;
}
extern "C" {
    #[doc = " Get the size of memory required to store mempool elements."]
    #[doc = ""]
    #[doc = " Calculate how much memory would be actually required with the given"]
    #[doc = " memory footprint to store required number of objects."]
    #[doc = ""]
    #[doc = " @param vaddr"]
    #[doc = "   Virtual address of the externally allocated memory buffer."]
    #[doc = "   Will be used to store mempool objects."]
    #[doc = " @param elt_num"]
    #[doc = "   Number of elements."]
    #[doc = " @param total_elt_sz"]
    #[doc = "   The size of each element, including header and trailer, as returned"]
    #[doc = "   by rte_mempool_calc_obj_size()."]
    #[doc = " @param paddr"]
    #[doc = "   Array of physical addresses of the pages that comprises given memory"]
    #[doc = "   buffer."]
    #[doc = " @param pg_num"]
    #[doc = "   Number of elements in the paddr array."]
    #[doc = " @param pg_shift"]
    #[doc = "   LOG2 of the physical pages size."]
    #[doc = " @return"]
    #[doc = "   On success, the number of bytes needed to store given number of"]
    #[doc = "   objects, aligned to the given page size. If the provided memory"]
    #[doc = "   buffer is too small, return a negative value whose absolute value"]
    #[doc = "   is the actual number of elements that can be stored in that buffer."]
    pub fn rte_mempool_xmem_usage(
        vaddr: *mut ::std::os::raw::c_void,
        elt_num: u32,
        total_elt_sz: usize,
        paddr: *const phys_addr_t,
        pg_num: u32,
        pg_shift: u32,
    ) -> isize;
}
extern "C" {
    #[doc = " Walk list of all memory pools"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the name of the l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the tunnel packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l2 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l3 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the inner_l4 packet type"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @return"]
    #[doc = "   A non-null string describing the packet type."]
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write the packet type name into the buffer"]
    #[doc = ""]
    #[doc = " @param ptype"]
    #[doc = "   The packet type value."]
    #[doc = " @param buf"]
    #[doc = "   The buffer where the string is written."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   - 0 on success"]
    #[doc = "   - (-1) if the buffer is too small"]
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a RX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the RX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a TX offload flag"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the flag. Usually only one bit must be set."]
    #[doc = "   Several bits can be given if they belong to the same mask."]
    #[doc = "   Ex: PKT_TX_L4_MASK."]
    #[doc = " @return"]
    #[doc = "   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer"]
    #[doc = ""]
    #[doc = " @param mask"]
    #[doc = "   The mask describing the TX flags."]
    #[doc = " @param buf"]
    #[doc = "   The output buffer."]
    #[doc = " @param buflen"]
    #[doc = "   The length of the buffer."]
    #[doc = " @return"]
    #[doc = "   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER8 = [u8; 0usize];
pub type MARKER64 = [u64; 0usize];
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer."]
    #[doc = " Force alignment to 8-bytes, so as to ensure we have the exact"]
    #[doc = " same mbuf cacheline0 layout for 32-bit and 64-bit. This makes"]
    #[doc = " working on vector drivers easier."]
    pub buf_physaddr: phys_addr_t,
    pub rearm_data: MARKER64,
    pub data_off: u16,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Number of segments."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports)."]
    pub port: u16,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if PKT_RX_VLAN_STRIPPED is set."]
    pub vlan_tci: u16,
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_3,
    #[doc = " Outer VLAN TCI (CPU order), valid if PKT_RX_QINQ_STRIPPED is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
    #[doc = " Valid if PKT_RX_TIMESTAMP is set. The unit and time reference"]
    #[doc = " are not normalized but are always the same for a given port."]
    pub timestamp: u64,
    pub cacheline1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_4,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    #[doc = "< Next segment of scattered packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_5,
    #[doc = " Size of the application private data. In case of an indirect"]
    #[doc = " mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = " Sequence number. See also rte_reorder_insert()."]
    pub seqn: u32,
    pub __bindgen_padding_0: [u64; 3usize],
}
#[doc = " Reference counter. Its size should at least equal to the size"]
#[doc = " of port field (16 bits), to support zero-copy broadcast."]
#[doc = " It should only be accessed using the following functions:"]
#[doc = " rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and"]
#[doc = " rte_mbuf_refcnt_set(). The functionality of these functions (atomic,"]
#[doc = " or non-atomic) is controlled by the CONFIG_RTE_MBUF_REFCNT_ATOMIC"]
#[doc = " config option."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    #[doc = "< Atomically accessed refcnt"]
    pub refcnt_atomic: rte_atomic16_t,
    #[doc = "< Non-atomically accessed refcnt"]
    pub refcnt: u16,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).refcnt_atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(refcnt_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_1>())).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(refcnt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l2_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u32,
        l3_type: u32,
        l4_type: u32,
        tun_type: u32,
        inner_l2_type: u32,
        inner_l3_type: u32,
        inner_l4_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u32 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u32 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u32 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u32 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let inner_l2_type: u32 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let inner_l3_type: u32 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let inner_l4_type: u32 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_2>())).packet_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(packet_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
    #[doc = "< Hierarchical scheduler"]
    pub sched: rte_mbuf__bindgen_ty_3__bindgen_ty_2,
    #[doc = "< User defined tags. See rte_distributor_process()"]
    pub usr: u32,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . hash as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . id as * const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>())).lo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>())).hi as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    pub lo: u32,
    pub hi: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>())).lo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>())).hi as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(hi)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).fdir as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).sched as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_3>())).usr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(usr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4 {
    #[doc = "< Can be used for external metadata"]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Allow 8-byte userdata on 32-bit"]
    pub udata64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4>())).userdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_4>())).udata64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(udata64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_5 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_5__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u16>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_5__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mbuf__bindgen_ty_5>())).tx_offload as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(tx_offload)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_physaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_physaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rearm_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rearm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_off as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).nb_segs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).port as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).ol_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).rx_descriptor_fields1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pkt_len as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).data_len as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).hash as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).vlan_tci_outer as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).buf_len as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timestamp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).cacheline1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).pool as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).next as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).priv_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).timesync as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timesync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mbuf>())).seqn as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(seqn)
        )
    );
}
#[doc = " Private data in case of pktmbuf pool."]
#[doc = ""]
#[doc = " A structure that contains some pktmbuf_pool-specific data that are"]
#[doc = " appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_pool_private>(),
        4usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_pool_private>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_data_room_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_data_room_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pktmbuf_pool_private>())).mbuf_priv_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_priv_size)
        )
    );
}
extern "C" {
    #[doc = " Sanity checks on an mbuf."]
    #[doc = ""]
    #[doc = " Check the consistency of the given mbuf. The function will cause a"]
    #[doc = " panic if corruption is detected."]
    #[doc = ""]
    #[doc = " @param m"]
    #[doc = "   The mbuf to be checked."]
    #[doc = " @param is_header"]
    #[doc = "   True if the mbuf is a packet header, false if it is a sub-segment"]
    #[doc = "   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " The control mbuf constructor."]
    #[doc = ""]
    #[doc = " This function initializes some fields in an mbuf structure that are"]
    #[doc = " not modified by the user once created (mbuf type, origin pool, buffer"]
    #[doc = " start address, and so on). This function is given as a callback function"]
    #[doc = " to rte_mempool_obj_iter() or rte_mempool_create() at pool creation time."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which the mbuf is allocated."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_obj_iter() or rte_mempool_create()."]
    #[doc = " @param m"]
    #[doc = "   The mbuf to initialize."]
    #[doc = " @param i"]
    #[doc = "   The index of the mbuf in the pool table."]
    pub fn rte_ctrlmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " The packet mbuf constructor."]
    #[doc = ""]
    #[doc = " This function initializes some fields in the mbuf structure that are"]
    #[doc = " not modified by the user once created (origin pool, buffer start"]
    #[doc = " address, and so on). This function is given as a callback function to"]
    #[doc = " rte_mempool_obj_iter() or rte_mempool_create() at pool creation time."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_obj_iter() or rte_mempool_create()."]
    #[doc = " @param m"]
    #[doc = "   The mbuf to initialize."]
    #[doc = " @param i"]
    #[doc = "   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " A  packet mbuf pool constructor."]
    #[doc = ""]
    #[doc = " This function initializes the mempool private data in the case of a"]
    #[doc = " pktmbuf pool. This private data is needed by the driver. The"]
    #[doc = " function must be called on the mempool before it is used, or it"]
    #[doc = " can be given as a callback function to rte_mempool_create() at"]
    #[doc = " pool creation. It can be extended by the user, for example, to"]
    #[doc = " provide another packet size."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   The mempool from which mbufs originate."]
    #[doc = " @param opaque_arg"]
    #[doc = "   A pointer that can be used by the user to retrieve useful information"]
    #[doc = "   for mbuf initialization. This pointer is the opaque argument passed to"]
    #[doc = "   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Create a mbuf pool."]
    #[doc = ""]
    #[doc = " This function creates and initializes a packet mbuf pool. It is"]
    #[doc = " a wrapper to rte_mempool functions."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mbuf pool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mbuf pool. The optimum size (in terms"]
    #[doc = "   of memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the per-core object cache. See rte_mempool_create() for"]
    #[doc = "   details."]
    #[doc = " @param priv_size"]
    #[doc = "   Size of application private are between the rte_mbuf structure"]
    #[doc = "   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN."]
    #[doc = " @param data_room_size"]
    #[doc = "   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier where the memory should be allocated. The"]
    #[doc = "   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the"]
    #[doc = "   reserved zone."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large, or priv_size is not aligned."]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_read()."]
    pub fn __rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Dump an mbuf structure to a file."]
    #[doc = ""]
    #[doc = " Dump all fields for the given packet mbuf and all its associated"]
    #[doc = " segments (in the case of a chained buffer)."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param m"]
    #[doc = "   The packet mbuf."]
    #[doc = " @param dump_len"]
    #[doc = "   If dump_len != 0, also dump the \"dump_len\" first data bytes of"]
    #[doc = "   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
#[doc = " Ethernet address:"]
#[doc = " A universally administered address is uniquely assigned to a device by its"]
#[doc = " manufacturer. The first three octets (in transmission order) contain the"]
#[doc = " Organizationally Unique Identifier (OUI). The following three (MAC-48 and"]
#[doc = " EUI-48) octets are assigned by that organization with the only constraint"]
#[doc = " of uniqueness."]
#[doc = " A locally administered address is assigned to a device by a network"]
#[doc = " administrator and does not contain OUIs."]
#[doc = " See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(
        ::std::mem::size_of::<ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_addr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_addr>())).addr_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
#[doc = " Ethernet header: Contains the destination address, source address"]
#[doc = " and frame type."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ether_hdr {
    #[doc = "< Destination address."]
    pub d_addr: ether_addr,
    #[doc = "< Source address."]
    pub s_addr: ether_addr,
    #[doc = "< Frame type."]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_ether_hdr() {
    assert_eq!(
        ::std::mem::size_of::<ether_hdr>(),
        14usize,
        concat!("Size of: ", stringify!(ether_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ether_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ether_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).d_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(d_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).s_addr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(s_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ether_hdr>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ether_hdr),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " Ethernet VLAN Header."]
#[doc = " Contains the 16-bit VLAN Tag Control Identifier and the Ethernet type"]
#[doc = " of the encapsulated frame."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vlan_hdr {
    #[doc = "< Priority (3) + CFI (1) + Identifier Code (12)"]
    pub vlan_tci: u16,
    #[doc = "< Ethernet type of encapsulated frame."]
    pub eth_proto: u16,
}
#[test]
fn bindgen_test_layout_vlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<vlan_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(vlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<vlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(vlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vlan_hdr>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vlan_hdr),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vlan_hdr>())).eth_proto as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vlan_hdr),
            "::",
            stringify!(eth_proto)
        )
    );
}
#[doc = " VXLAN protocol header."]
#[doc = " Contains the 8-bit flag, 24-bit VXLAN Network Identifier and"]
#[doc = " Reserved fields (24 bits and 8 bits)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vxlan_hdr {
    #[doc = "< flag (8) + Reserved (24)."]
    pub vx_flags: u32,
    #[doc = "< VNI (24) + Reserved (8)."]
    pub vx_vni: u32,
}
#[test]
fn bindgen_test_layout_vxlan_hdr() {
    assert_eq!(
        ::std::mem::size_of::<vxlan_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(vxlan_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<vxlan_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(vxlan_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_hdr>())).vx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_hdr),
            "::",
            stringify!(vx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vxlan_hdr>())).vx_vni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vxlan_hdr),
            "::",
            stringify!(vx_vni)
        )
    );
}
pub const rte_filter_type_RTE_ETH_FILTER_NONE: rte_filter_type = 0;
pub const rte_filter_type_RTE_ETH_FILTER_MACVLAN: rte_filter_type = 1;
pub const rte_filter_type_RTE_ETH_FILTER_ETHERTYPE: rte_filter_type = 2;
pub const rte_filter_type_RTE_ETH_FILTER_FLEXIBLE: rte_filter_type = 3;
pub const rte_filter_type_RTE_ETH_FILTER_SYN: rte_filter_type = 4;
pub const rte_filter_type_RTE_ETH_FILTER_NTUPLE: rte_filter_type = 5;
pub const rte_filter_type_RTE_ETH_FILTER_TUNNEL: rte_filter_type = 6;
pub const rte_filter_type_RTE_ETH_FILTER_FDIR: rte_filter_type = 7;
pub const rte_filter_type_RTE_ETH_FILTER_HASH: rte_filter_type = 8;
pub const rte_filter_type_RTE_ETH_FILTER_L2_TUNNEL: rte_filter_type = 9;
pub const rte_filter_type_RTE_ETH_FILTER_GENERIC: rte_filter_type = 10;
pub const rte_filter_type_RTE_ETH_FILTER_MAX: rte_filter_type = 11;
#[doc = " Feature filter types"]
pub type rte_filter_type = u32;
#[doc = " used to check whether the type filter is supported"]
pub const rte_filter_op_RTE_ETH_FILTER_NOP: rte_filter_op = 0;
#[doc = "< add filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_ADD: rte_filter_op = 1;
#[doc = "< update filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_UPDATE: rte_filter_op = 2;
#[doc = "< delete filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_DELETE: rte_filter_op = 3;
#[doc = "< flush all entries"]
pub const rte_filter_op_RTE_ETH_FILTER_FLUSH: rte_filter_op = 4;
#[doc = "< get filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_GET: rte_filter_op = 5;
#[doc = "< configurations"]
pub const rte_filter_op_RTE_ETH_FILTER_SET: rte_filter_op = 6;
#[doc = "< retrieve information"]
pub const rte_filter_op_RTE_ETH_FILTER_INFO: rte_filter_op = 7;
#[doc = "< retrieve statistics"]
pub const rte_filter_op_RTE_ETH_FILTER_STATS: rte_filter_op = 8;
pub const rte_filter_op_RTE_ETH_FILTER_OP_MAX: rte_filter_op = 9;
#[doc = " Generic operations on filters"]
pub type rte_filter_op = u32;
#[doc = "< exact match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_PERFECT_MATCH: rte_mac_filter_type = 1;
#[doc = "< exact match of MAC addr and VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_PERFECT_MATCH: rte_mac_filter_type = 2;
#[doc = "< hash match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_HASH_MATCH: rte_mac_filter_type = 3;
#[doc = " hash match of MAC addr and exact match of VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_HASH_MATCH: rte_mac_filter_type = 4;
#[doc = " MAC filter type"]
pub type rte_mac_filter_type = u32;
#[doc = " MAC filter info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_filter {
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
    #[doc = "< MAC filter type"]
    pub filter_type: rte_mac_filter_type,
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_filter>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).is_vf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).dst_id as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(dst_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).filter_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_filter>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_filter),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " A structure used to define the ethertype filter entry"]
#[doc = " to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ethertype_filter {
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
    #[doc = "< Ether type to match"]
    pub ether_type: u16,
    #[doc = "< Flags from RTE_ETHTYPE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ethertype_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ethertype_filter>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ethertype_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_ethertype_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).mac_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(mac_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).ether_type as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ethertype_filter>())).queue as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ethertype_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = "  A structure used to define the flex filter entry"]
#[doc = "  to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,"]
#[doc = "  RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    #[doc = "< flex bytes in big endian."]
    pub bytes: [u8; 128usize],
    #[doc = "< if mask bit is 1b, do"]
    #[doc = "not compare corresponding byte."]
    pub mask: [u8; 16usize],
    pub priority: u8,
    #[doc = "< Queue assigned to when match."]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_flex_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_filter>(),
        150usize,
        concat!("Size of: ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).bytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).mask as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).priority as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_filter>())).queue as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " A structure used to define the TCP syn filter entry"]
#[doc = " to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_syn_filter {
    #[doc = "< 1 - higher priority than other filters,"]
    #[doc = "0 - lower priority."]
    pub hig_pri: u8,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_syn_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_syn_filter>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_syn_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_syn_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).hig_pri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(hig_pri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_syn_filter>())).queue as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_syn_filter),
            "::",
            stringify!(queue)
        )
    );
}
#[doc = " A structure used to define the ntuple filter entry"]
#[doc = " to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,"]
#[doc = " RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP."]
    #[doc = "The packet matched above ntuple fields and contain"]
    #[doc = "any set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,"]
    #[doc = "used when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_ntuple_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ntuple_filter>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ntuple_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ntuple_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_ip_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_ip_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_ip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).dst_port_mask as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).src_port_mask as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).proto_mask as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(proto_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).tcp_flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(tcp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).priority as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ntuple_filter>())).queue as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ntuple_filter),
            "::",
            stringify!(queue)
        )
    );
}
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NONE: rte_eth_tunnel_type = 0;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_VXLAN: rte_eth_tunnel_type = 1;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_GENEVE: rte_eth_tunnel_type = 2;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_TEREDO: rte_eth_tunnel_type = 3;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NVGRE: rte_eth_tunnel_type = 4;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_IP_IN_GRE: rte_eth_tunnel_type = 5;
pub const rte_eth_tunnel_type_RTE_L2_TUNNEL_TYPE_E_TAG: rte_eth_tunnel_type = 6;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_MAX: rte_eth_tunnel_type = 7;
#[doc = " Tunneled type."]
pub type rte_eth_tunnel_type = u32;
#[doc = "< IPv4."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV4: rte_tunnel_iptype = 0;
#[doc = "< IPv6."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV6: rte_tunnel_iptype = 1;
#[doc = "  Select IPv4 or IPv6 for tunnel filters."]
pub type rte_tunnel_iptype = u32;
#[doc = " Tunneling Packet filter configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_filter_conf {
    #[doc = "< Outer MAC address to match."]
    pub outer_mac: ether_addr,
    #[doc = "< Inner MAC address to match."]
    pub inner_mac: ether_addr,
    #[doc = "< Inner VLAN to match."]
    pub inner_vlan: u16,
    #[doc = "< IP address type."]
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    #[doc = " Flags from ETH_TUNNEL_FILTER_XX - see above."]
    pub filter_type: u16,
    #[doc = "< Tunnel Type."]
    pub tunnel_type: rte_eth_tunnel_type,
    #[doc = "< Tenant ID to match. VNI, GRE key..."]
    pub tenant_id: u32,
    #[doc = "< Queue assigned to if match."]
    pub queue_id: u16,
}
#[doc = " Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP"]
#[doc = "is set in filter_type, or inner destination IP address to match"]
#[doc = "if ETH_TUNNEL_FILTER_IIP is set in filter_type ."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    #[doc = "< IPv4 address in big endian."]
    pub ipv4_addr: u32,
    #[doc = "< IPv6 address in big endian."]
    pub ipv6_addr: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv4_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv4_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf__bindgen_ty_1>())).ipv6_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf__bindgen_ty_1),
            "::",
            stringify!(ipv6_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_filter_conf>(),
        52usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_filter_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_filter_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).outer_mac as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(outer_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_mac as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).inner_vlan as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(inner_vlan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).ip_addr as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).filter_type as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(filter_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tunnel_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).tenant_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(tenant_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_tunnel_filter_conf>())).queue_id as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_filter_conf),
            "::",
            stringify!(queue_id)
        )
    );
}
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN: rte_eth_global_cfg_type = 0;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN: rte_eth_global_cfg_type = 1;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_MAX: rte_eth_global_cfg_type = 2;
#[doc = " Global eth device configuration type."]
pub type rte_eth_global_cfg_type = u32;
#[doc = " Global eth device configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_global_cfg {
    #[doc = "< Global config type."]
    pub cfg_type: rte_eth_global_cfg_type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_global_cfg__bindgen_ty_1 {
    #[doc = "< Valid GRE key length in byte."]
    pub gre_key_len: u8,
    #[doc = "< Reserve space for future use."]
    pub reserved: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).gre_key_len as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(gre_key_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_global_cfg__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_global_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_global_cfg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_global_cfg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_global_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_global_cfg>())).cfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_global_cfg),
            "::",
            stringify!(cfg)
        )
    );
}
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_UNKNOWN: rte_eth_input_set_field = 0;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_SRC_MAC: rte_eth_input_set_field = 1;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_DST_MAC: rte_eth_input_set_field = 2;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_OUTER_VLAN: rte_eth_input_set_field = 3;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_INNER_VLAN: rte_eth_input_set_field = 4;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_ETHERTYPE: rte_eth_input_set_field = 5;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP4: rte_eth_input_set_field = 129;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP4: rte_eth_input_set_field = 130;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP6: rte_eth_input_set_field = 131;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP6: rte_eth_input_set_field = 132;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TOS: rte_eth_input_set_field = 133;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_PROTO: rte_eth_input_set_field = 134;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_TC: rte_eth_input_set_field = 135;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: rte_eth_input_set_field =
    136;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TTL: rte_eth_input_set_field = 137;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: rte_eth_input_set_field =
    138;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: rte_eth_input_set_field = 257;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: rte_eth_input_set_field = 258;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: rte_eth_input_set_field = 259;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: rte_eth_input_set_field = 260;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: rte_eth_input_set_field = 261;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: rte_eth_input_set_field = 262;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG:
    rte_eth_input_set_field = 263;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC:
    rte_eth_input_set_field = 385;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC:
    rte_eth_input_set_field = 386;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: rte_eth_input_set_field =
    387;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: rte_eth_input_set_field =
    388;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: rte_eth_input_set_field = 389;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: rte_eth_input_set_field =
    641;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: rte_eth_input_set_field =
    642;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: rte_eth_input_set_field =
    643;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: rte_eth_input_set_field =
    644;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: rte_eth_input_set_field =
    645;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: rte_eth_input_set_field =
    646;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: rte_eth_input_set_field =
    647;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: rte_eth_input_set_field =
    648;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_DEFAULT: rte_eth_input_set_field = 65533;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_NONE: rte_eth_input_set_field = 65534;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_MAX: rte_eth_input_set_field = 65535;
#[doc = " Input set fields for Flow Director and Hash filters"]
pub type rte_eth_input_set_field = u32;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_UNKNOWN: rte_filter_input_set_op = 0;
#[doc = "< select input set"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_SELECT: rte_filter_input_set_op = 1;
#[doc = "< add input set entry"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_ADD: rte_filter_input_set_op = 2;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_MAX: rte_filter_input_set_op = 3;
#[doc = " Filters input set operations"]
pub type rte_filter_input_set_op = u32;
#[doc = " A structure used to define the input set configuration for"]
#[doc = " flow director and hash filters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[test]
fn bindgen_test_layout_rte_eth_input_set_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_input_set_conf>(),
        520usize,
        concat!("Size of: ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_input_set_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_input_set_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_input_set_conf>())).inset_size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(inset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).field as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_input_set_conf>())).op as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_input_set_conf),
            "::",
            stringify!(op)
        )
    );
}
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Size of: ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_flow>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_flow>())).ether_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_flow),
            "::",
            stringify!(ether_type)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv4_flow>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).tos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).ttl as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv4_flow>())).proto as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv4_flow),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv4_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv4_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv4_flow>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv4_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv4_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).src_port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).dst_port as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv4_flow>())).verify_tag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv4_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_ipv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_ipv6_flow>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_ipv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_ipv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).tc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).proto as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_ipv6_flow>())).hop_limits as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_ipv6_flow),
            "::",
            stringify!(hop_limits)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_udpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_udpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_tcpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tcpv6_flow>(),
        40usize,
        concat!("Size of: ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tcpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tcpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tcpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tcpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
}
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_sctpv6_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_sctpv6_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_sctpv6_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_sctpv6_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).src_port as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(src_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).dst_port as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_sctpv6_flow>())).verify_tag as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_sctpv6_flow),
            "::",
            stringify!(verify_tag)
        )
    );
}
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_mac_vlan_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mac_vlan_flow>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mac_vlan_flow>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_mac_vlan_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mac_vlan_flow>())).mac_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mac_vlan_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_UNKNOWN: rte_eth_fdir_tunnel_type = 0;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_NVGRE: rte_eth_fdir_tunnel_type = 1;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_VXLAN: rte_eth_fdir_tunnel_type = 2;
#[doc = " Tunnel type for flow director."]
pub type rte_eth_fdir_tunnel_type = u32;
#[doc = " A structure used to define the input for tunnel flow, now it's VxLAN or"]
#[doc = " NVGRE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: ether_addr,
}
#[test]
fn bindgen_test_layout_rte_eth_tunnel_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_tunnel_flow>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_tunnel_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_tunnel_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).tunnel_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_tunnel_flow>())).mac_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_tunnel_flow),
            "::",
            stringify!(mac_addr)
        )
    );
}
#[doc = " An union contains the inputs for all types of flow"]
#[doc = " Items in flows need to be in big endian"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
    _bindgen_union_align: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow>(),
        44usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).l2_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(l2_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ip4_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ip4_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).udp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(udp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tcp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tcp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).sctp6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(sctp6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).ipv6_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(ipv6_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).mac_vlan_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(mac_vlan_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow>())).tunnel_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow),
            "::",
            stringify!(tunnel_flow)
        )
    );
}
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flow_ext() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flow_ext>(),
        22usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flow_ext>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flow_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).vlan_tci as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).flexbytes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(flexbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).is_vf as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(is_vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flow_ext>())).dst_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flow_ext),
            "::",
            stringify!(dst_id)
        )
    );
}
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_input() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_input>(),
        72usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_input>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_input))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_input>())).flow_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_input),
            "::",
            stringify!(flow_ext)
        )
    );
}
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_ACCEPT: rte_eth_fdir_behavior = 0;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_REJECT: rte_eth_fdir_behavior = 1;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_PASSTHRU: rte_eth_fdir_behavior = 2;
#[doc = " Behavior will be taken if FDIR match"]
pub type rte_eth_fdir_behavior = u32;
#[doc = "< Report nothing."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_NO_REPORT_STATUS: rte_eth_fdir_status = 0;
#[doc = "< Only report FD ID."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID: rte_eth_fdir_status = 1;
#[doc = "< Report FD ID and 4 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID_FLEX_4: rte_eth_fdir_status = 2;
#[doc = "< Report 8 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_FLEX_8: rte_eth_fdir_status = 3;
#[doc = " Flow director report status"]
#[doc = " It defines what will be reported if FDIR entry is matched."]
pub type rte_eth_fdir_status = u32;
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_action() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_action>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_action>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).rx_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).behavior as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_action>())).report_status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(report_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_action>())).flex_off as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_action),
            "::",
            stringify!(flex_off)
        )
    );
}
#[doc = " A structure used to define the flow director filter entry by filter_ctrl API"]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and"]
#[doc = " RTE_ETH_FILTER_DELETE operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter>(),
        92usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).soft_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(soft_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).input as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter>())).action as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter),
            "::",
            stringify!(action)
        )
    );
}
#[doc = "  A structure used to configure FDIR masks that are used by the device"]
#[doc = "  to match the various fields of RX packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit maks for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the"]
    #[doc = "first byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,"]
    #[doc = "0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_masks() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_masks>(),
        68usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_masks>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_masks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).vlan_tci_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(vlan_tci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv4_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv4_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_masks>())).ipv6_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(ipv6_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).src_port_mask as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(src_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).dst_port_mask as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(dst_port_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).mac_addr_byte_mask as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(mac_addr_byte_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_id_mask as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_id_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_masks>())).tunnel_type_mask as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_masks),
            "::",
            stringify!(tunnel_type_mask)
        )
    );
}
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_UNKNOWN: rte_eth_payload_type = 0;
pub const rte_eth_payload_type_RTE_ETH_RAW_PAYLOAD: rte_eth_payload_type = 1;
pub const rte_eth_payload_type_RTE_ETH_L2_PAYLOAD: rte_eth_payload_type = 2;
pub const rte_eth_payload_type_RTE_ETH_L3_PAYLOAD: rte_eth_payload_type = 3;
pub const rte_eth_payload_type_RTE_ETH_L4_PAYLOAD: rte_eth_payload_type = 4;
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_MAX: rte_eth_payload_type = 8;
#[doc = " Payload type"]
pub type rte_eth_payload_type = u32;
#[doc = " A structure used to select bytes extracted from the protocol layers to"]
#[doc = " flexible payload for filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_flex_payload_cfg() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_flex_payload_cfg>(),
        36usize,
        concat!("Size of: ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_flex_payload_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_flex_payload_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_flex_payload_cfg>())).src_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_flex_payload_cfg),
            "::",
            stringify!(src_offset)
        )
    );
}
#[doc = " A structure used to define FDIR masks for flexible payload"]
#[doc = " for each flow type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_mask() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_mask>(),
        18usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_mask>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_mask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).flow_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_mask>())).mask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_mask),
            "::",
            stringify!(mask)
        )
    );
}
#[doc = " A structure used to define all flexible payload related setting"]
#[doc = " include flex payload and flex mask"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 22usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_flex_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_flex_conf>(),
        688usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_flex_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_flex_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_payloads as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_payloads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).nb_flexmasks as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(nb_flexmasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_set as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_flex_conf>())).flex_mask as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_flex_conf),
            "::",
            stringify!(flex_mask)
        )
    );
}
#[doc = "< Disable FDIR support."]
pub const rte_fdir_mode_RTE_FDIR_MODE_NONE: rte_fdir_mode = 0;
#[doc = "< Enable FDIR signature filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_SIGNATURE: rte_fdir_mode = 1;
#[doc = "< Enable FDIR perfect filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT: rte_fdir_mode = 2;
#[doc = "< Enable FDIR filter mode - MAC VLAN."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_MAC_VLAN: rte_fdir_mode = 3;
#[doc = "< Enable FDIR filter mode - tunnel."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_TUNNEL: rte_fdir_mode = 4;
#[doc = "  Flow Director setting modes: none, signature or perfect."]
pub type rte_fdir_mode = u32;
#[doc = " A structure used to get the information of flow director filter."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation."]
#[doc = " It includes the mode, flexible payload configuration information,"]
#[doc = " capabilities and supported flow types, flexible payload characters."]
#[doc = " It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u32; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex"]
    #[doc = "payload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments."]
    #[doc = "Each segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that"]
    #[doc = "src_offset[i] in struct rte_eth_flex_payload_cfg should be less"]
    #[doc = "than this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a"]
    #[doc = "multiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_info>(),
        796usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_conf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).guarant_spc as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(guarant_spc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_info>())).best_spc as *const _ as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(best_spc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flow_types_mask as *const _ as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flow_types_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flexpayload as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flexpayload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_unit as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_payload_segment_num as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_payload_segment_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_payload_limit as *const _ as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_payload_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).flex_bitmask_unit as *const _ as usize
        },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(flex_bitmask_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_info>())).max_flex_bitmask_num as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_info),
            "::",
            stringify!(max_flex_bitmask_num)
        )
    );
}
#[doc = " A structure used to define the statistics of flow director."]
#[doc = " It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_stats>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).collision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(collision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).free as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxhash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).add as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_add as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).f_remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(f_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).guarant_cnt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(guarant_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_stats>())).best_cnt as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_stats),
            "::",
            stringify!(best_cnt)
        )
    );
}
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN:
    rte_eth_fdir_filter_info_type = 0;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT:
    rte_eth_fdir_filter_info_type = 1;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX:
    rte_eth_fdir_filter_info_type = 2;
#[doc = " Flow Director filter information types."]
pub type rte_eth_fdir_filter_info_type = u32;
#[doc = " A structure used to set FDIR filter information, to support filter type"]
#[doc = " of 'RTE_ETH_FILTER_FDIR' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_fdir_filter_info_type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
#[doc = " Details of fdir filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_filter_info__bindgen_ty_1 {
    #[doc = " Flow Director input set configuration per port"]
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_fdir_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fdir_filter_info>(),
        524usize,
        concat!("Size of: ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fdir_filter_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fdir_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fdir_filter_info>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fdir_filter_info),
            "::",
            stringify!(info)
        )
    );
}
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN:
    rte_eth_hash_filter_info_type = 0;
#[doc = " Symmetric hash enable per port"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT:
    rte_eth_hash_filter_info_type = 1;
#[doc = " Configure globally for hash filter"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_GLOBAL_CONFIG:
    rte_eth_hash_filter_info_type = 2;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INPUT_SET_SELECT:
    rte_eth_hash_filter_info_type = 3;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_MAX:
    rte_eth_hash_filter_info_type = 4;
#[doc = " Hash filter information types."]
#[doc = " - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the"]
#[doc = "   information/configuration of 'symmetric hash enable' per port."]
#[doc = " - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global"]
#[doc = "   configurations of hash filters. Those global configurations are valid"]
#[doc = "   for all ports of the same NIC."]
#[doc = " - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global"]
#[doc = "   hash input set fields"]
pub type rte_eth_hash_filter_info_type = u32;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 3;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = u32;
#[doc = " A structure used to set or get global hash function configurations which"]
#[doc = " include symmetric hash enable per flow type and hash function type."]
#[doc = " Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the"]
#[doc = " corresponding flow type is enabled or not."]
#[doc = " Each bit in valid_bit_mask[] indicates if the corresponding bit in"]
#[doc = " sym_hash_enable_mask[] is valid or not. For the configurations gotten, it"]
#[doc = " also means if the flow type is supported by hardware or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hash_global_conf {
    #[doc = "< Hash function type"]
    pub hash_func: rte_eth_hash_function,
    #[doc = " Bit mask for symmetric hash enable per flow type"]
    pub sym_hash_enable_mask: [u32; 1usize],
    #[doc = " Bit mask indicates if the corresponding bit is valid"]
    pub valid_bit_mask: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_global_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_global_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_global_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_global_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).hash_func as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(hash_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).sym_hash_enable_mask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(sym_hash_enable_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_global_conf>())).valid_bit_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_global_conf),
            "::",
            stringify!(valid_bit_mask)
        )
    );
}
#[doc = " A structure used to set or get hash filter information, to support filter"]
#[doc = " type of 'RTE_ETH_FILTER_HASH' and its operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hash_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_hash_filter_info_type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
#[doc = " Details of hash filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_hash_filter_info__bindgen_ty_1 {
    #[doc = " For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT"]
    pub enable: u8,
    #[doc = " Global configurations of hash filter"]
    pub global_conf: rte_eth_hash_global_conf,
    #[doc = " Global configurations of hash filter input set"]
    pub input_set_conf: rte_eth_input_set_conf,
    _bindgen_union_align: [u32; 130usize],
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        520usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).enable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).global_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(global_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info__bindgen_ty_1>())).input_set_conf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info__bindgen_ty_1),
            "::",
            stringify!(input_set_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_hash_filter_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_hash_filter_info>(),
        524usize,
        concat!("Size of: ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_hash_filter_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_hash_filter_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_hash_filter_info>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_hash_filter_info),
            "::",
            stringify!(info)
        )
    );
}
#[doc = " l2 tunnel configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_l2_tunnel_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_l2_tunnel_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_l2_tunnel_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_l2_tunnel_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).l2_tunnel_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(l2_tunnel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).ether_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).tunnel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).vf_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(vf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_l2_tunnel_conf>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_l2_tunnel_conf),
            "::",
            stringify!(pool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_reg_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_reg_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_reg_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_reg_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_reg_info>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_reg_info),
            "::",
            stringify!(version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return eeprom"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start eeprom address for access"]
    pub offset: u32,
    #[doc = "< Length of eeprom region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[test]
fn bindgen_test_layout_rte_dev_eeprom_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_eeprom_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_eeprom_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_eeprom_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_eeprom_info>())).magic as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_eeprom_info),
            "::",
            stringify!(magic)
        )
    );
}
#[doc = " A structure used to retrieve statistics for an Ethernet port."]
#[doc = " Not all statistics fields in struct rte_eth_stats are supported"]
#[doc = " by any type of network interface card (NIC). If any statistics"]
#[doc = " field is not supported, its value is 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ipackets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).opackets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ibytes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).obytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).imissed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).ierrors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).oerrors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).rx_nombuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ipackets as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_opackets as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_ibytes as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_obytes as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_stats>())).q_errors as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_link {
    #[doc = "< ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_link>())).link_speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_link),
            "::",
            stringify!(link_speed)
        )
    );
}
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure the ring threshold registers of an RX/TX"]
#[doc = " queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).pthresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).hthresh as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_thresh>())).wthresh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
#[doc = " None of DCB,RSS or VMDQ mode"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For RX side, only RSS is on"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For RX side,only DCB is on."]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDQ, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDQ"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDQ+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDQ and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route"]
#[doc = "  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = u32;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For TX side,only DCB is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For TX side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit"]
#[doc = " packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = u32;
#[doc = " A structure used to configure the RX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Only used if jumbo_frame enabled."]
    pub max_rx_pkt_len: u32,
    #[doc = "< hdr buf size (header_split enabled)."]
    pub split_hdr_size: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).max_rx_pkt_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_rx_pkt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxmode>())).split_hdr_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(split_hdr_size)
        )
    );
}
impl rte_eth_rxmode {
    #[inline]
    pub fn header_split(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_header_split(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_ip_checksum(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hw_ip_checksum(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_filter(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_filter(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_strip(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_strip(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_extend(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hw_vlan_extend(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jumbo_frame(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jumbo_frame(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_strip_crc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hw_strip_crc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_scatter(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enable_scatter(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_lro(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enable_lro(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        header_split: u16,
        hw_ip_checksum: u16,
        hw_vlan_filter: u16,
        hw_vlan_strip: u16,
        hw_vlan_extend: u16,
        jumbo_frame: u16,
        hw_strip_crc: u16,
        enable_scatter: u16,
        enable_lro: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let header_split: u16 = unsafe { ::std::mem::transmute(header_split) };
            header_split as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_ip_checksum: u16 = unsafe { ::std::mem::transmute(hw_ip_checksum) };
            hw_ip_checksum as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_filter: u16 = unsafe { ::std::mem::transmute(hw_vlan_filter) };
            hw_vlan_filter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hw_vlan_strip: u16 = unsafe { ::std::mem::transmute(hw_vlan_strip) };
            hw_vlan_strip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hw_vlan_extend: u16 = unsafe { ::std::mem::transmute(hw_vlan_extend) };
            hw_vlan_extend as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let jumbo_frame: u16 = unsafe { ::std::mem::transmute(jumbo_frame) };
            jumbo_frame as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hw_strip_crc: u16 = unsafe { ::std::mem::transmute(hw_strip_crc) };
            hw_strip_crc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let enable_scatter: u16 = unsafe { ::std::mem::transmute(enable_scatter) };
            enable_scatter as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let enable_lro: u16 = unsafe { ::std::mem::transmute(enable_lro) };
            enable_lro as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const rte_vlan_type_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN."]
#[doc = " Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = u32;
#[doc = " A structure used to describe a vlan filter."]
#[doc = " If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_rte_vlan_filter_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_vlan_filter_conf>(),
        512usize,
        concat!("Size of: ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_vlan_filter_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_vlan_filter_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_vlan_filter_conf>())).ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_vlan_filter_conf),
            "::",
            stringify!(ids)
        )
    );
}
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature"]
#[doc = " of an Ethernet port."]
#[doc = " If not NULL, the *rss_key* pointer of the *rss_conf* structure points"]
#[doc = " to an array holding the RSS key to use for hashing specific header"]
#[doc = " fields of received packets. The length of this array should be indicated"]
#[doc = " by *rss_key_len* below. Otherwise, a default random hash key is used by"]
#[doc = " the device driver."]
#[doc = ""]
#[doc = " The *rss_key_len* field of the *rss_conf* structure indicates the length"]
#[doc = " in bytes of the array pointed by *rss_key*. To be compatible, this length"]
#[doc = " will be checked in i40e only. Others assume 40 bytes to be used as before."]
#[doc = ""]
#[doc = " The *rss_hf* field of the *rss_conf* structure indicates the different"]
#[doc = " types of IPv4/IPv6 packets to which the RSS hashing must be applied."]
#[doc = " Supplying an *rss_hf* equal to zero disables the RSS feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = "< If not NULL, 40-byte hash key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = "< Hash functions to apply - see below."]
    pub rss_hf: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_conf>())).rss_hf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
}
#[doc = " A structure used to configure VLAN traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    #[doc = "< mask for valid VLAN ID."]
    pub vlan_mask: u64,
    #[doc = " VLAN ID list for vlan mirroring."]
    pub vlan_id: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vlan_mirror() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vlan_mirror>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vlan_mirror>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vlan_mirror))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vlan_mirror>())).vlan_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vlan_mirror),
            "::",
            stringify!(vlan_id)
        )
    );
}
#[doc = " A structure used to configure traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_mirror_conf {
    #[doc = "< Mirroring rule type"]
    pub rule_type: u8,
    #[doc = "< Destination pool for this mirror rule."]
    pub dst_pool: u8,
    #[doc = "< Bitmap of pool for pool mirroring"]
    pub pool_mask: u64,
    #[doc = " VLAN ID setting for VLAN mirroring."]
    pub vlan: rte_eth_vlan_mirror,
}
#[test]
fn bindgen_test_layout_rte_eth_mirror_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_mirror_conf>(),
        152usize,
        concat!("Size of: ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_mirror_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_mirror_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).rule_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(rule_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).dst_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(dst_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).pool_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(pool_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_mirror_conf>())).vlan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_mirror_conf),
            "::",
            stringify!(vlan)
        )
    );
}
#[doc = " A structure used to configure 64 entries of Redirection Table of the"]
#[doc = " Receive Side Scaling (RSS) feature of an Ethernet port. To configure"]
#[doc = " more than 64 entries supported by hardware, an array of this structure"]
#[doc = " is needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rss_reta_entry64() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_reta_entry64>(),
        136usize,
        concat!("Size of: ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_reta_entry64>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_reta_entry64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rss_reta_entry64>())).reta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_reta_entry64),
            "::",
            stringify!(reta)
        )
    );
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes"]
#[doc = " in DCB configurations"]
pub type rte_eth_nb_tcs = u32;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools"]
#[doc = " in VMDQ configurations."]
pub type rte_eth_nb_pools = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_rx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_tx_conf>())).dcb_tc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_tx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
#[doc = " A structure used to configure the VMDQ+DCB feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues, based"]
#[doc = " on the vlan id in the vlan tag, and then to a specific queue within"]
#[doc = " that pool, using the user priority vlan tag field."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).nb_pool_maps as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).pool_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_dcb_conf>())).dcb_tc as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[doc = " A structure used to configure the VMDQ feature of an Ethernet port when"]
#[doc = " not combined with the DCB feature."]
#[doc = ""]
#[doc = " Using this feature, packets are routed to a pool of queues. By default,"]
#[doc = " the pool selection is based on the MAC address, the vlan id in the"]
#[doc = " vlan tag as specified in the pool_map array."]
#[doc = " Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool"]
#[doc = " selection using only the MAC address. MAC address to pool mapping is done"]
#[doc = " using the rte_eth_dev_mac_addr_add function, with the pool parameter"]
#[doc = " corresponding to the pool id."]
#[doc = ""]
#[doc = " Queue selection within the selected pool will be done using RSS when"]
#[doc = " it is enabled or revert to the first queue of the pool if not."]
#[doc = ""]
#[doc = " A default pool may be used, if desired, to route all traffic which"]
#[doc = " does not match the vlan filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).vlan_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf__bindgen_ty_1>())).pools as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_queue_pools as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_default_pool as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).default_pool as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).enable_loop_back as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).nb_pool_maps as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).rx_mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_vmdq_rx_conf>())).pool_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
#[doc = " A structure used to configure the TX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< TX multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    pub pvid: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).mq_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txmode>())).pvid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(pvid)
        )
    );
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an RX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< RX ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of RX descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_free_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_drop_en as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxconf>())).rx_deferred_start as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
}
#[doc = " A structure used to configure a TX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< TX ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing TX buffers if there are"]
    #[doc = "less free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Set flags for the Tx queue"]
    pub txq_flags: u32,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_thresh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_rs_thresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).tx_free_thresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txconf>())).txq_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(txq_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_txconf>())).tx_deferred_start as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet."]
    #[doc = ""]
    #[doc = " - For TSO packet this is the total number of data descriptors allowed"]
    #[doc = "   by device."]
    #[doc = ""]
    #[doc = " @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU."]
    #[doc = ""]
    #[doc = " - For non-TSO packet, this is the maximum allowed number of segments"]
    #[doc = "   in a single transmit packet."]
    #[doc = ""]
    #[doc = " - For TSO packet each segment within the TSO may span up to this"]
    #[doc = "   value."]
    #[doc = ""]
    #[doc = " @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_min as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_align as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_seg_max as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_desc_lim>())).nb_mtu_seg_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< RX pause frame, enable flowctrl on TX side."]
pub const rte_eth_fc_mode_RTE_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< TX pause frame, enable flowctrl on RX side."]
pub const rte_eth_fc_mode_RTE_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = u32;
#[doc = " A structure used to configure Ethernet flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_fc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_fc_conf>(),
        20usize,
        concat!("Size of: ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_fc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_fc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).high_water as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(high_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).low_water as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(low_water)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).pause_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(pause_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).send_xon as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(send_xon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).mode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_fc_conf>())).mac_ctrl_frame_fwd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(mac_ctrl_frame_fwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_fc_conf>())).autoneg as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_fc_conf),
            "::",
            stringify!(autoneg)
        )
    );
}
#[doc = " A structure used to configure Ethernet priority flow control parameter."]
#[doc = " These parameters will be configured into the register of the NIC."]
#[doc = " Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_pfc_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_pfc_conf>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_pfc_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_pfc_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).fc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(fc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_pfc_conf>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_pfc_conf),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = "< 64k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_64K: rte_fdir_pballoc_type = 0;
#[doc = "< 128k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_128K: rte_fdir_pballoc_type = 1;
#[doc = "< 256k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_256K: rte_fdir_pballoc_type = 2;
#[doc = "  Memory space that can be configured to store Flow Director filters"]
#[doc = "  in the board memory."]
pub type rte_fdir_pballoc_type = u32;
#[doc = "< Never report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_NO_REPORT_STATUS: rte_fdir_status_mode = 0;
#[doc = "< Only report FDIR hash for matching pkts."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS: rte_fdir_status_mode = 1;
#[doc = "< Always report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS_ALWAYS: rte_fdir_status_mode = 2;
#[doc = "  Select report mode of FDIR hash information in RX descriptors."]
pub type rte_fdir_status_mode = u32;
#[doc = " A structure used to configure the Flow Director (FDIR) feature"]
#[doc = " of an Ethernet port."]
#[doc = ""]
#[doc = " If mode is RTE_FDIR_DISABLE, the pballoc value is ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fdir_conf {
    #[doc = "< Flow Director mode."]
    pub mode: rte_fdir_mode,
    #[doc = "< Space for FDIR filters."]
    pub pballoc: rte_fdir_pballoc_type,
    #[doc = "< How to report FDIR hash."]
    pub status: rte_fdir_status_mode,
    #[doc = " RX queue of packets matching a \"drop\" filter in perfect mode."]
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[test]
fn bindgen_test_layout_rte_fdir_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_fdir_conf>(),
        772usize,
        concat!("Size of: ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fdir_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_fdir_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).pballoc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(pballoc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).drop_queue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(drop_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fdir_conf>())).flex_conf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fdir_conf),
            "::",
            stringify!(flex_conf)
        )
    );
}
#[doc = " UDP tunneling configuration."]
#[doc = " Used to config the UDP port for a type of tunnel."]
#[doc = " NICs need the UDP port to identify the tunnel type."]
#[doc = " Normally a type of tunnel has a default UDP port, this structure can be used"]
#[doc = " in case if the users want to change or support more UDP port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. Defined in rte_eth_tunnel_type."]
    pub prot_type: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_udp_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_udp_tunnel>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_udp_tunnel>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_udp_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).udp_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(udp_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_udp_tunnel>())).prot_type as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_udp_tunnel),
            "::",
            stringify!(prot_type)
        )
    );
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_intr_conf {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_intr_conf))
    );
}
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port."]
#[doc = " Depending upon the RX multi-queue mode, extra advanced"]
#[doc = " configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of ETH_LINK_SPEED_XXX of speeds to be"]
    #[doc = "used. ETH_LINK_SPEED_FIXED disables link"]
    #[doc = "autonegotiation, and a unique speed shall be"]
    #[doc = "set. Otherwise, the bitmap defines the set of"]
    #[doc = "speeds to be advertised. If the special value"]
    #[doc = "ETH_LINK_SPEED_AUTONEG (0) is used, all speeds"]
    #[doc = "supported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port RX configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port TX configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value"]
    #[doc = "is 0, meaning the loopback mode is disabled."]
    #[doc = "Read the datasheet of given ethernet controller"]
    #[doc = "for details. The possible values of this field"]
    #[doc = "are defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port RX filtering configuration (union)."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port TX DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC"]
    #[doc = "is needed,and the variable must be set ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< FDIR configuration."]
    pub fdir_conf: rte_fdir_conf,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2120usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).rss_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_dcb_conf as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).dcb_rx_conf as *const _ as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_1>())).vmdq_rx_conf as *const _ as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_dcb_tx_conf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).dcb_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_conf__bindgen_ty_2>())).vmdq_tx_conf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        2944usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).link_speeds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rxmode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rxmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).txmode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(txmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).lpbk_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).rx_adv_conf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).tx_adv_conf as *const _ as usize },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).dcb_capability_en as *const _ as usize },
        2164usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).fdir_conf as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(fdir_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_conf>())).intr_conf as *const _ as usize },
        2940usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
#[doc = " Ethernet device information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Device PCI information."]
    pub pci_dev: *mut rte_pci_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none."]
    #[doc = "Use if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum size of RX buffer."]
    pub min_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of RX pkt."]
    pub max_rx_pktlen: u32,
    #[doc = "< Maximum number of RX queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of TX queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Device RX offload capabilities."]
    pub rx_offload_capa: u32,
    #[doc = "< Device TX offload capabilities."]
    pub tx_offload_capa: u32,
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    #[doc = " Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default RX configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default TX configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDQ pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDQ pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDQ pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< RX descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< TX descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        128usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).pci_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(pci_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).driver_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).if_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).min_rx_bufsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_pktlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_rx_queues as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_tx_queues as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_mac_addrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).max_hash_mac_addrs as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vfs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).max_vmdq_pools as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_offload_capa as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_offload_capa as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).reta_size as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).hash_key_size as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).flow_type_rss_offloads as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_rxconf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).default_txconf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_base as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_queue_num as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).vmdq_pool_base as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).rx_desc_lim as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).tx_desc_lim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).speed_capa as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_rx_queues as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_info>())).nb_tx_queues as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
}
#[doc = " Ethernet device RX queue information structure."]
#[doc = " Used to retieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets RX supported."]
    pub scattered_rx: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_rxq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).mp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).conf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).scattered_rx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(scattered_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxq_info>())).nb_desc as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
#[doc = " Ethernet device TX queue information structure."]
#[doc = " Used to retieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
    pub __bindgen_padding_0: [u16; 23usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txq_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txq_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_txq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_txq_info>())).nb_desc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txq_info),
            "::",
            stringify!(nb_desc)
        )
    );
}
#[doc = " An Ethernet device extended statistic structure"]
#[doc = ""]
#[doc = " This structure is used by rte_eth_xstats_get() to provide"]
#[doc = " statistics that are not provided in the generic *rte_eth_stats*"]
#[doc = " structure."]
#[doc = " It maps a name id, corresponding to an index in the array returned"]
#[doc = " by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_xstat() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " A name element for extended statistics."]
#[doc = ""]
#[doc = " An array of this structure is returned by rte_eth_xstats_get_names()."]
#[doc = " It lists the names of extended statistics for a PMD. The *rte_eth_xstat*"]
#[doc = " structure references these names by their array index."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_rte_eth_xstat_name() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_xstat_name>(),
        64usize,
        concat!("Size of: ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_xstat_name>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_xstat_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_xstat_name>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_xstat_name),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " A structure used to get the information of queue and"]
#[doc = " TC mapping on both TX and RX paths."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>())).nb_queue
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2),
            "::",
            stringify!(nb_queue)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tc_queue_mapping() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>(),
        2048usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tc_queue_mapping))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_rxq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_rxq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dcb_tc_queue_mapping>())).tc_txq as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tc_queue_mapping),
            "::",
            stringify!(tc_txq)
        )
    );
}
#[doc = " A structure used to get the information of DCB."]
#[doc = " It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< TX BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_info>(),
        2065usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_info>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).nb_tcs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).prio_tc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(prio_tc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_bws as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_bws)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dcb_info>())).tc_queue as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_info),
            "::",
            stringify!(tc_queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[doc = " @internal Structure to keep track of registered callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_cb_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_cb_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_cb_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_cb_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_cb_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_cb_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_close_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, igb_stats: *mut rte_eth_stats),
>;
pub type eth_stats_reset_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_reset_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        ids: *const u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, dev_info: *mut rte_eth_dev_info),
>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> *const u32>;
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue: *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_offload_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, mask: ::std::os::raw::c_int)>;
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mac_addr_set_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, mac_addr: *mut ether_addr)>;
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_reset_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rule_id: u8) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_eth_type_conf_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_filter_ctrl_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        filter_type: rte_filter_type,
        filter_op: rte_filter_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @internal A structure containing the functions exported by an Ethernet driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_dev_ops {
    #[doc = "< Configure device."]
    pub dev_configure: eth_dev_configure_t,
    #[doc = "< Start device."]
    pub dev_start: eth_dev_start_t,
    #[doc = "< Stop device."]
    pub dev_stop: eth_dev_stop_t,
    #[doc = "< Device link up."]
    pub dev_set_link_up: eth_dev_set_link_up_t,
    #[doc = "< Device link down."]
    pub dev_set_link_down: eth_dev_set_link_down_t,
    #[doc = "< Close device."]
    pub dev_close: eth_dev_close_t,
    #[doc = "< Get device link state."]
    pub link_update: eth_link_update_t,
    #[doc = "< Promiscuous ON."]
    pub promiscuous_enable: eth_promiscuous_enable_t,
    #[doc = "< Promiscuous OFF."]
    pub promiscuous_disable: eth_promiscuous_disable_t,
    #[doc = "< RX multicast ON."]
    pub allmulticast_enable: eth_allmulticast_enable_t,
    #[doc = "< RX multicast OFF."]
    pub allmulticast_disable: eth_allmulticast_disable_t,
    #[doc = "< Remove MAC address."]
    pub mac_addr_remove: eth_mac_addr_remove_t,
    #[doc = "< Add a MAC address."]
    pub mac_addr_add: eth_mac_addr_add_t,
    #[doc = "< Set a MAC address."]
    pub mac_addr_set: eth_mac_addr_set_t,
    #[doc = "< set list of mcast addrs."]
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    #[doc = "< Set MTU."]
    pub mtu_set: mtu_set_t,
    #[doc = "< Get generic device statistics."]
    pub stats_get: eth_stats_get_t,
    #[doc = "< Reset generic device statistics."]
    pub stats_reset: eth_stats_reset_t,
    #[doc = "< Get extended device statistics."]
    pub xstats_get: eth_xstats_get_t,
    #[doc = "< Reset extended device statistics."]
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    #[doc = "< Get device info."]
    pub dev_infos_get: eth_dev_infos_get_t,
    #[doc = "< retrieve RX queue information."]
    pub rxq_info_get: eth_rxq_info_get_t,
    #[doc = "< retrieve TX queue information."]
    pub txq_info_get: eth_txq_info_get_t,
    #[doc = "< Get firmware version."]
    pub fw_version_get: eth_fw_version_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    #[doc = "< Filter VLAN Setup."]
    pub vlan_filter_set: vlan_filter_set_t,
    #[doc = "< Outer/Inner VLAN TPID Setup."]
    pub vlan_tpid_set: vlan_tpid_set_t,
    #[doc = "< VLAN Stripping on queue."]
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    #[doc = "< Set VLAN Offload."]
    pub vlan_offload_set: vlan_offload_set_t,
    #[doc = "< Set port based TX VLAN insertion."]
    pub vlan_pvid_set: vlan_pvid_set_t,
    #[doc = "< Start RX for a queue."]
    pub rx_queue_start: eth_queue_start_t,
    #[doc = "< Stop RX for a queue."]
    pub rx_queue_stop: eth_queue_stop_t,
    #[doc = "< Start TX for a queue."]
    pub tx_queue_start: eth_queue_start_t,
    #[doc = "< Stop TX for a queue."]
    pub tx_queue_stop: eth_queue_stop_t,
    #[doc = "< Set up device RX queue."]
    pub rx_queue_setup: eth_rx_queue_setup_t,
    #[doc = "< Release RX queue."]
    pub rx_queue_release: eth_queue_release_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    #[doc = "< Check rxd DD bit."]
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    #[doc = "< Enable Rx queue interrupt."]
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    #[doc = "< Disable Rx queue interrupt."]
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    #[doc = "< Set up device TX queue."]
    pub tx_queue_setup: eth_tx_queue_setup_t,
    #[doc = "< Release TX queue."]
    pub tx_queue_release: eth_queue_release_t,
    #[doc = "< Free tx ring mbufs"]
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    #[doc = "< Turn on LED."]
    pub dev_led_on: eth_dev_led_on_t,
    #[doc = "< Turn off LED."]
    pub dev_led_off: eth_dev_led_off_t,
    #[doc = "< Get flow control."]
    pub flow_ctrl_get: flow_ctrl_get_t,
    #[doc = "< Setup flow control."]
    pub flow_ctrl_set: flow_ctrl_set_t,
    #[doc = "< Setup priority flow control."]
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    #[doc = "< Set Unicast Table Array."]
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    #[doc = "< Set Unicast hash bitmap."]
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    #[doc = "< Add a traffic mirror rule."]
    pub mirror_rule_set: eth_mirror_rule_set_t,
    #[doc = "< reset a traffic mirror rule."]
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    #[doc = " Add UDP tunnel port."]
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    #[doc = " Del UDP tunnel port."]
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    #[doc = " Config ether type of l2 tunnel."]
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
    #[doc = "< Set queue rate limit."]
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    pub rss_hash_update: rss_hash_update_t,
    #[doc = " Configure RSS hash protocols."]
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    #[doc = " Get current RSS hash configuration."]
    pub reta_update: reta_update_t,
    #[doc = " Update redirection table."]
    pub reta_query: reta_query_t,
    #[doc = "< Get registers."]
    pub get_reg: eth_get_reg_t,
    #[doc = "< Get eeprom length."]
    pub get_eeprom_length: eth_get_eeprom_length_t,
    #[doc = "< Get eeprom data."]
    pub get_eeprom: eth_get_eeprom_t,
    #[doc = "< Set eeprom."]
    pub set_eeprom: eth_set_eeprom_t,
    #[doc = "< common filter control."]
    pub filter_ctrl: eth_filter_ctrl_t,
    pub get_dcb_info: eth_get_dcb_info,
    #[doc = " Get DCB information."]
    pub timesync_enable: eth_timesync_enable_t,
    #[doc = " Turn IEEE1588/802.1AS timestamping on."]
    pub timesync_disable: eth_timesync_disable_t,
    #[doc = " Turn IEEE1588/802.1AS timestamping off."]
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    #[doc = " Read the IEEE1588/802.1AS RX timestamp."]
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    #[doc = " Read the IEEE1588/802.1AS TX timestamp."]
    pub timesync_adjust_time: eth_timesync_adjust_time,
    #[doc = " Adjust the device clock."]
    pub timesync_read_time: eth_timesync_read_time,
    #[doc = " Get the device clock time."]
    pub timesync_write_time: eth_timesync_write_time,
    #[doc = " Set the device clock time."]
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub tm_ops_get: eth_tm_ops_get_t,
}
#[test]
fn bindgen_test_layout_eth_dev_ops() {
    assert_eq!(
        ::std::mem::size_of::<eth_dev_ops>(),
        648usize,
        concat!("Size of: ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<eth_dev_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(eth_dev_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_configure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_stop as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_up as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_set_link_down as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_set_link_down)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).link_update as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(link_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_enable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).promiscuous_disable as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(promiscuous_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_enable as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).allmulticast_disable as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(allmulticast_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_remove as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_add as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mac_addr_set as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mac_addr_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_mc_addr_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_mc_addr_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mtu_set as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mtu_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_get as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).stats_reset as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(stats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_reset as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).queue_stats_mapping_set as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(queue_stats_mapping_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_infos_get as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_infos_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rxq_info_get as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rxq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).txq_info_get as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(txq_info_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).fw_version_get as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(fw_version_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).dev_supported_ptypes_get as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_supported_ptypes_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_filter_set as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_filter_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_tpid_set as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_tpid_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).vlan_strip_queue_set as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_strip_queue_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_offload_set as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_offload_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).vlan_pvid_set as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(vlan_pvid_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_start as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_stop as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_start as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_stop as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_setup as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_release as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_count as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_done as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_done)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_descriptor_status as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).tx_descriptor_status as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_descriptor_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_enable as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).rx_queue_intr_disable as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rx_queue_intr_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_setup as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_queue_release as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_queue_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tx_done_cleanup as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tx_done_cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_on as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).dev_led_off as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(dev_led_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_get as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).flow_ctrl_set as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).priority_flow_ctrl_set as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(priority_flow_ctrl_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).uc_hash_table_set as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_hash_table_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).uc_all_hash_table_set as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(uc_all_hash_table_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_set as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).mirror_rule_reset as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(mirror_rule_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_add as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).udp_tunnel_port_del as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(udp_tunnel_port_del)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_eth_type_conf as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_eth_type_conf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).l2_tunnel_offload_set as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(l2_tunnel_offload_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).set_queue_rate_limit as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_queue_rate_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_update as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).rss_hash_conf_get as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(rss_hash_conf_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_update as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).reta_query as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(reta_query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_reg as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom_length as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_eeprom as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).set_eeprom as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(set_eeprom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).filter_ctrl as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(filter_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).get_dcb_info as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(get_dcb_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_enable as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_disable as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_disable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_rx_timestamp as *const _ as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_rx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_tx_timestamp as *const _ as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_tx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).timesync_adjust_time as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_adjust_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_read_time as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_read_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).timesync_write_time as *const _ as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(timesync_write_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_by_id as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_by_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<eth_dev_ops>())).xstats_get_names_by_id as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(xstats_get_names_by_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<eth_dev_ops>())).tm_ops_get as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(eth_dev_ops),
            "::",
            stringify!(tm_ops_get)
        )
    );
}
#[doc = " Function type used for RX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on RX with a burst of packets that have"]
#[doc = " been received on the given port and queue."]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   The Ethernet port on which RX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to receive the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that have just been received."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param max_pkts"]
#[doc = "   The max number of packets that can be stored in the \"pkts\" array."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port: u8,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for TX packet processing packet callbacks."]
#[doc = ""]
#[doc = " The callback function is called on TX with a burst of packets immediately"]
#[doc = " before the packets are put onto the hardware queue for transmission."]
#[doc = ""]
#[doc = " @param port"]
#[doc = "   The Ethernet port on which TX is being performed."]
#[doc = " @param queue"]
#[doc = "   The queue on the Ethernet port which is being used to transmit the packets."]
#[doc = " @param pkts"]
#[doc = "   The burst of packets that are about to be transmitted."]
#[doc = " @param nb_pkts"]
#[doc = "   The number of packets in the burst pointed to by \"pkts\"."]
#[doc = " @param user_param"]
#[doc = "   The arbitrary user parameter passed in by the application when the callback"]
#[doc = "   was originally configured."]
#[doc = " @return"]
#[doc = "   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port: u8,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " @internal"]
#[doc = " Structure used to hold information about the callbacks to be called for a"]
#[doc = " queue on RX and TX."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).rx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_rxtx_callback__bindgen_ty_1>())).tx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback__bindgen_ty_1),
            "::",
            stringify!(tx)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_rxtx_callback() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxtx_callback>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxtx_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxtx_callback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_rxtx_callback>())).param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxtx_callback),
            "::",
            stringify!(param)
        )
    );
}
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
pub const rte_eth_dev_state_RTE_ETH_DEV_DEFERRED: rte_eth_dev_state = 2;
#[doc = " A set of values to describe the possible states of an eth device."]
pub type rte_eth_dev_state = u32;
#[doc = " @internal"]
#[doc = " The generic data structure associated with each ethernet device."]
#[doc = ""]
#[doc = " Pointers to burst-oriented packet receive and transmit functions are"]
#[doc = " located at the beginning of the structure, along with the pointer to"]
#[doc = " where all the data elements for the particular device are stored in shared"]
#[doc = " memory. This split allows the function pointer and driver data to be per-"]
#[doc = " process, while the actual configuration data for the device is shared."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev {
    #[doc = "< Pointer to PMD receive function."]
    pub rx_pkt_burst: eth_rx_burst_t,
    #[doc = "< Pointer to PMD transmit function."]
    pub tx_pkt_burst: eth_tx_burst_t,
    #[doc = "< Pointer to PMD transmit prepare function."]
    pub tx_pkt_prepare: eth_tx_prep_t,
    #[doc = "< Pointer to device data"]
    pub data: *mut rte_eth_dev_data,
    #[doc = "< Functions exported by PMD"]
    pub dev_ops: *const eth_dev_ops,
    #[doc = "< Backing device"]
    pub device: *mut rte_device,
    #[doc = "< Device interrupt handle"]
    pub intr_handle: *mut rte_intr_handle,
    #[doc = " User application callbacks for NIC interrupts"]
    pub link_intr_cbs: rte_eth_dev_cb_list,
    #[doc = " User-supplied functions called from rx_burst to post-process"]
    #[doc = " received packets before passing them to the user"]
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = " User-supplied functions called from tx_burst to pre-process"]
    #[doc = " received packets before passing them to the driver for transmission."]
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    #[doc = "< Flag indicating the port state"]
    pub state: rte_eth_dev_state,
    pub __bindgen_padding_0: [u32; 13usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev>(),
        16512usize,
        concat!("Size of: ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_eth_dev))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).rx_pkt_burst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(rx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).tx_pkt_prepare as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(tx_pkt_prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).dev_ops as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(dev_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).intr_handle as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(intr_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).link_intr_cbs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(link_intr_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).post_rx_burst_cbs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(post_rx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).pre_tx_burst_cbs as *const _ as usize },
        8264usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(pre_tx_burst_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev>())).state as *const _ as usize },
        16456usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_sriov() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_sriov>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_sriov>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_sriov))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).nb_q_per_pool as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(nb_q_per_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_vmdq_idx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_vmdq_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_sriov>())).def_pool_q_idx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_sriov),
            "::",
            stringify!(def_pool_q_idx)
        )
    );
}
#[doc = " @internal"]
#[doc = " The data part, with no function pointers, associated with each ethernet device."]
#[doc = ""]
#[doc = " This structure is safe to place in shared memory to be common among different"]
#[doc = " processes in a multi-process configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    #[doc = "< Unique identifier name"]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Array of pointers to RX queues."]
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Array of pointers to TX queues."]
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
    #[doc = "< SRIOV data"]
    pub sriov: rte_eth_dev_sriov,
    #[doc = "< PMD-specific private data"]
    pub dev_private: *mut ::std::os::raw::c_void,
    pub dev_link: rte_eth_link,
    #[doc = "< Configuration applied to device."]
    pub dev_conf: rte_eth_conf,
    #[doc = "< Maximum Transmission Unit."]
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    #[doc = "< RX ring mbuf allocation failures."]
    pub rx_mbuf_alloc_failed: u64,
    #[doc = "< Device Ethernet Link address."]
    pub mac_addrs: *mut ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    #[doc = " bitmap array of associating Ethernet MAC addresses to pools"]
    pub hash_mac_addrs: *mut ether_addr,
    #[doc = "< Device [external] port identifier."]
    pub port_id: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rx_queue_state: [u8; 1024usize],
    #[doc = " Queues state: STARTED(1) / STOPPED(0)"]
    pub tx_queue_state: [u8; 1024usize],
    #[doc = "< Capabilities"]
    pub dev_flags: u32,
    #[doc = "< Kernel driver passthrough"]
    pub kdrv: rte_kernel_driver,
    #[doc = "< NUMA node connection"]
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_data() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_data>(),
        6656usize,
        concat!("Size of: ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queues as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queues as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_rx_queues as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).nb_tx_queues as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).sriov as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(sriov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_private as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_link as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_conf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mtu as *const _ as usize },
        3024usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).min_rx_buf_size as *const _ as usize
        },
        3028usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(min_rx_buf_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_mbuf_alloc_failed as *const _ as usize
        },
        3032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_mbuf_alloc_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_addrs as *const _ as usize },
        3040usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).mac_pool_sel as *const _ as usize },
        3048usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(mac_pool_sel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).hash_mac_addrs as *const _ as usize },
        4072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).port_id as *const _ as usize },
        4080usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).rx_queue_state as *const _ as usize },
        4082usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(rx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).tx_queue_state as *const _ as usize },
        5106usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(tx_queue_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).dev_flags as *const _ as usize },
        6132usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).kdrv as *const _ as usize },
        6136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(kdrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_eth_dev_data>())).numa_node as *const _ as usize },
        6140usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_eth_dev_data>())).vlan_filter_conf as *const _ as usize
        },
        6144usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_data),
            "::",
            stringify!(vlan_filter_conf)
        )
    );
}
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
extern "C" {
    #[doc = " Iterates over valid ethdev ports."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The id of the next possible valid port."]
    #[doc = " @return"]
    #[doc = "   Next valid port id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u8) -> u8;
}
extern "C" {
    #[doc = " Get the total number of Ethernet devices that have been successfully"]
    #[doc = " initialized by the matching Ethernet driver during the PCI probing phase"]
    #[doc = " and that are available for applications to use. These devices must be"]
    #[doc = " accessed by using the ``RTE_ETH_FOREACH_DEV()`` macro to deal with"]
    #[doc = " non-contiguous ranges of devices."]
    #[doc = " These non-contiguous ranges can be created by calls to hotplug functions or"]
    #[doc = " by some PMDs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - The total number of usable Ethernet devices."]
    pub fn rte_eth_dev_count() -> u8;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Returns a ethdev slot specified by the unique identifier name."]
    #[doc = ""]
    #[doc = " @param\tname"]
    #[doc = "  The pointer to the Unique identifier name for each Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - The pointer to the ethdev slot, on success. NULL on error"]
    pub fn rte_eth_dev_allocated(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Allocates a new ethdev slot for an ethernet device and returns the pointer"]
    #[doc = " to that slot for the driver to use."]
    #[doc = ""]
    #[doc = " @param\tname\tUnique identifier name for each Ethernet device"]
    #[doc = " @param\ttype\tDevice type of this Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - Slot in the rte_dev_devices array for a new device;"]
    pub fn rte_eth_dev_allocate(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Attach to the ethdev already initialized by the primary"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " @param       name    Ethernet device's name."]
    #[doc = " @return"]
    #[doc = "   - Success: Slot in the rte_dev_devices array for attached"]
    #[doc = "        device."]
    #[doc = "   - Error: Null pointer."]
    pub fn rte_eth_dev_attach_secondary(name: *const ::std::os::raw::c_char) -> *mut rte_eth_dev;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Release the specified ethdev port."]
    #[doc = ""]
    #[doc = " @param eth_dev"]
    #[doc = " The *eth_dev* pointer is the address of the *rte_eth_dev* structure."]
    #[doc = " @return"]
    #[doc = "   - 0 on success, negative on error"]
    pub fn rte_eth_dev_release_port(eth_dev: *mut rte_eth_dev) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attach a new Ethernet device specified by arguments."]
    #[doc = ""]
    #[doc = " @param devargs"]
    #[doc = "  A pointer to a strings array describing the new device"]
    #[doc = "  to be attached. The strings should be a pci address like"]
    #[doc = "  '0000:01:00.0' or virtual device name like 'net_pcap0'."]
    #[doc = " @param port_id"]
    #[doc = "  A pointer to a port identifier actually attached."]
    #[doc = " @return"]
    #[doc = "  0 on success and port_id is filled, negative on error"]
    pub fn rte_eth_dev_attach(
        devargs: *const ::std::os::raw::c_char,
        port_id: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Detach a Ethernet device specified by port identifier."]
    #[doc = " This function must be called when the device is in the"]
    #[doc = " closed state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device to detach."]
    #[doc = " @param devname"]
    #[doc = "   A pointer to a buffer that will be filled with the device name."]
    #[doc = "   This buffer must be at least RTE_DEV_NAME_MAX_LEN long."]
    #[doc = " @return"]
    #[doc = "  0 on success and devname is filled, negative on error"]
    pub fn rte_eth_dev_detach(
        port_id: u8,
        devname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in"]
    #[doc = " the bitmap link_speeds of the struct rte_eth_conf"]
    #[doc = ""]
    #[doc = " @param speed"]
    #[doc = "   Numerical speed value in Mbps"]
    #[doc = " @param duplex"]
    #[doc = "   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)"]
    #[doc = " @return"]
    #[doc = "   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[doc = " Configure an Ethernet device."]
    #[doc = " This function must be invoked first before any other function in the"]
    #[doc = " Ethernet API. This function can also be re-invoked when a device is in the"]
    #[doc = " stopped state."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device to configure."]
    #[doc = " @param nb_rx_queue"]
    #[doc = "   The number of receive queues to set up for the Ethernet device."]
    #[doc = " @param nb_tx_queue"]
    #[doc = "   The number of transmit queues to set up for the Ethernet device."]
    #[doc = " @param eth_conf"]
    #[doc = "   The pointer to the configuration data to be used for the Ethernet device."]
    #[doc = "   The *rte_eth_conf* structure includes:"]
    #[doc = "     -  the hardware offload features to activate, with dedicated fields for"]
    #[doc = "        each statically configurable offload hardware feature provided by"]
    #[doc = "        Ethernet devices, such as IP checksum or VLAN tag stripping for"]
    #[doc = "        example."]
    #[doc = "     - the Receive Side Scaling (RSS) configuration when using multiple RX"]
    #[doc = "         queues per port."]
    #[doc = ""]
    #[doc = "   Embedding all configuration information in a single data structure"]
    #[doc = "   is the more flexible method that allows the addition of new features"]
    #[doc = "   without changing the syntax of the API."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, device configured."]
    #[doc = "   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u8,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Release device queues and clear its configuration to force the user"]
    #[doc = " application to reconfigure it. It is for internal use only."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to struct rte_eth_dev."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  void"]
    pub fn _rte_eth_dev_reset(dev: *mut rte_eth_dev);
}
extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " The function allocates a contiguous block of memory for *nb_rx_desc*"]
    #[doc = " receive descriptors from a memory zone associated with *socket_id*"]
    #[doc = " and initializes each receive descriptor with a network buffer allocated"]
    #[doc = " from the memory pool *mb_pool*."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue to set up."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   The number of receive descriptors to allocate for the receive ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the receive descriptors of the ring."]
    #[doc = " @param rx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the receive queue."]
    #[doc = "   NULL value is allowed, in which case default RX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *rx_conf* structure contains an *rx_thresh* structure with the values"]
    #[doc = "   of the Prefetch, Host, and Write-Back threshold registers of the receive"]
    #[doc = "   ring."]
    #[doc = " @param mb_pool"]
    #[doc = "   The pointer to the memory pool from which to allocate *rte_mbuf* network"]
    #[doc = "   memory buffers to populate each descriptor of the receive ring."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, receive queue correctly set up."]
    #[doc = "   - -EINVAL: The size of network buffers which can be allocated from the"]
    #[doc = "      memory pool does not fit the various buffer sizes allowed by the"]
    #[doc = "      device controller."]
    #[doc = "   - -ENOMEM: Unable to allocate the receive ring descriptors or to"]
    #[doc = "      allocate network memory buffers from the memory pool when"]
    #[doc = "      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u8,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue to set up."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   The number of transmit descriptors to allocate for the transmit ring."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    #[doc = "   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for"]
    #[doc = "   the DMA memory allocated for the transmit descriptors of the ring."]
    #[doc = " @param tx_conf"]
    #[doc = "   The pointer to the configuration data to be used for the transmit queue."]
    #[doc = "   NULL value is allowed, in which case default RX configuration"]
    #[doc = "   will be used."]
    #[doc = "   The *tx_conf* structure contains the following data:"]
    #[doc = "   - The *tx_thresh* structure with the values of the Prefetch, Host, and"]
    #[doc = "     Write-Back threshold registers of the transmit ring."]
    #[doc = "     When setting Write-Back threshold to the value greater then zero,"]
    #[doc = "     *tx_rs_thresh* value should be explicitly set to one."]
    #[doc = "   - The *tx_free_thresh* value indicates the [minimum] number of network"]
    #[doc = "     buffers that must be pending in the transmit ring to trigger their"]
    #[doc = "     [implicit] freeing by the driver transmit function."]
    #[doc = "   - The *tx_rs_thresh* value indicates the [minimum] number of transmit"]
    #[doc = "     descriptors that must be pending in the transmit ring before setting the"]
    #[doc = "     RS bit on a descriptor by the driver transmit function."]
    #[doc = "     The *tx_rs_thresh* value should be less or equal then"]
    #[doc = "     *tx_free_thresh* value, and both of them should be less then"]
    #[doc = "     *nb_tx_desc* - 3."]
    #[doc = "   - The *txq_flags* member contains flags to pass to the TX queue setup"]
    #[doc = "     function to configure the behavior of the TX queue. This should be set"]
    #[doc = "     to 0 if no special configuration is required."]
    #[doc = ""]
    #[doc = "     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces"]
    #[doc = "     the transmit function to use default values."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is correctly set up."]
    #[doc = "   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u8,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   The NUMA socket id to which the Ethernet device is connected or"]
    #[doc = "   a default of zero if the socket could not be determined."]
    #[doc = "   -1 is returned is the port_id value is out of range."]
    pub fn rte_eth_dev_socket_id(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if port_id of device is attached"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @return"]
    #[doc = "   - 0 if port is out of range or not attached"]
    #[doc = "   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start specified RX queue of a port. It is used when rx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is started."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u8, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified RX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the rx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the receive queue is stopped."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u8, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start TX for specified queue of a port. It is used when tx_deferred_start"]
    #[doc = " flag of the specified queue is true."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is started."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u8, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop specified TX queue of a port"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device"]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the tx queue to update the ring."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, the transmit queue is stopped."]
    #[doc = "   - -EINVAL: The port_id or the queue_id out of range."]
    #[doc = "   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u8, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an Ethernet device."]
    #[doc = ""]
    #[doc = " The device start step is the last one and consists of setting the configured"]
    #[doc = " offload features and in starting the transmit and the receive units of the"]
    #[doc = " device."]
    #[doc = " On success, all basic functions exported by the Ethernet API (link status,"]
    #[doc = " receive/transmit, and so on) can be invoked."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device started."]
    #[doc = "   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to"]
    #[doc = " rte_eth_dev_start()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_stop(port_id: u8);
}
extern "C" {
    #[doc = " Link up an Ethernet device."]
    #[doc = ""]
    #[doc = " Set device link up will re-enable the device rx/tx"]
    #[doc = " functionality after it is previously set device linked down."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - 0: Success, Ethernet device linked up."]
    #[doc = "   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Link down an Ethernet device."]
    #[doc = " The device rx/tx functionality will be disabled if success,"]
    #[doc = " and it can be re-enabled with a call to"]
    #[doc = " rte_eth_dev_set_link_up()"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!"]
    #[doc = " The function frees all resources except for needed by the"]
    #[doc = " closed state. To free these resources, call rte_eth_dev_detach()."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_close(port_id: u8);
}
extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_promiscuous_enable(port_id: u8);
}
extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_promiscuous_disable(port_id: u8);
}
extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if promiscuous is enabled"]
    #[doc = "   - (0) if promiscuous is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_allmulticast_enable(port_id: u8);
}
extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_allmulticast_disable(port_id: u8);
}
extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (1) if allmulticast is enabled"]
    #[doc = "   - (0) if allmulticast is disabled."]
    #[doc = "   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX"]
    #[doc = " or FULL-DUPLEX) of the physical link of an Ethernet device. It might need"]
    #[doc = " to wait up to 9 seconds in it."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   A pointer to an *rte_eth_link* structure to be filled with"]
    #[doc = "   the status, the speed and the mode of the Ethernet device link."]
    pub fn rte_eth_link_get(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX"]
    #[doc = " or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait"]
    #[doc = " version of rte_eth_link_get()."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param link"]
    #[doc = "   A pointer to an *rte_eth_link* structure to be filled with"]
    #[doc = "   the status, the speed and the mode of the Ethernet device link."]
    pub fn rte_eth_link_get_nowait(port_id: u8, link: *mut rte_eth_link);
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param stats"]
    #[doc = "   A pointer to a structure of type *rte_eth_stats* to be filled with"]
    #[doc = "   the values of device counters for the following set of statistics:"]
    #[doc = "   - *ipackets* with the total of successfully received packets."]
    #[doc = "   - *opackets* with the total of successfully transmitted packets."]
    #[doc = "   - *ibytes*   with the total of successfully received bytes."]
    #[doc = "   - *obytes*   with the total of successfully transmitted bytes."]
    #[doc = "   - *ierrors*  with the total of erroneous received packets."]
    #[doc = "   - *oerrors*  with the total of failed transmitted packets."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u8, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_stats_reset(port_id: u8);
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u8,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats"]
    #[doc = "   A pointer to a table of structure of type *rte_eth_xstat*"]
    #[doc = "   to be filled with device statistics ids and values: id is the"]
    #[doc = "   index of the name string in xstats_names (see rte_eth_xstats_get_names()),"]
    #[doc = "   and value is the statistic counter."]
    #[doc = "   This parameter can be set to NULL if n is 0."]
    #[doc = " @param n"]
    #[doc = "   The size of the xstats array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to n: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than n: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get(
        port_id: u8,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param xstats_names"]
    #[doc = "   An rte_eth_xstat_name array of at least *size* elements to"]
    #[doc = "   be filled. If set to NULL, the function returns the required number"]
    #[doc = "   of elements."]
    #[doc = " @param ids"]
    #[doc = "   IDs array given by app to retrieve specific statistics"]
    #[doc = " @param size"]
    #[doc = "   The size of the xstats_names array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to size: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than size: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u8,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ids"]
    #[doc = "   A pointer to an ids array passed by application. This tells which"]
    #[doc = "   statistics values function should retrieve. This parameter"]
    #[doc = "   can be set to NULL if n is 0. In this case function will retrieve"]
    #[doc = "   all avalible statistics."]
    #[doc = " @param values"]
    #[doc = "   A pointer to a table to be filled with device statistics values."]
    #[doc = " @param n"]
    #[doc = "   The size of the ids array (number of elements)."]
    #[doc = " @return"]
    #[doc = "   - A positive value lower or equal to n: success. The return value"]
    #[doc = "     is the number of entries filled in the stats table."]
    #[doc = "   - A positive value higher than n: error, the given statistics table"]
    #[doc = "     is too small. The return value corresponds to the size that should"]
    #[doc = "     be given to succeed. The entries in the table are not valid and"]
    #[doc = "     shall not be used by the caller."]
    #[doc = "   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u8,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the ID of a statistic from its name."]
    #[doc = ""]
    #[doc = " This function searches for the statistics using string compares, and"]
    #[doc = " as such should not be used on the fast-path. For fast-path retrieval of"]
    #[doc = " specific statistics, store the ID as provided in *id* from this function,"]
    #[doc = " and pass the ID to rte_eth_xstats_get()"]
    #[doc = ""]
    #[doc = " @param port_id The port to look up statistics from"]
    #[doc = " @param xstat_name The name of the statistic to return"]
    #[doc = " @param[out] id A pointer to an app-supplied uint64_t which should be"]
    #[doc = "                set to the ID of the stat if the stat exists."]
    #[doc = " @return"]
    #[doc = "    0 on success"]
    #[doc = "    -ENODEV for invalid port_id,"]
    #[doc = "    -EINVAL if the xstat_name doesn't exist in port_id"]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u8,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    pub fn rte_eth_xstats_reset(port_id: u8);
}
extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tx_queue_id"]
    #[doc = "   The index of the transmit queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the transmit"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1]."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u8,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue"]
    #[doc = "  statistics counter."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param stat_idx"]
    #[doc = "   The per-queue packet statistics functionality number that the receive"]
    #[doc = "   queue is to be assigned."]
    #[doc = "   The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1]."]
    #[doc = " @return"]
    #[doc = "   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u8,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   A pointer to a structure of type *ether_addr* to be filled with"]
    #[doc = "   the Ethernet address of the Ethernet device."]
    pub fn rte_eth_macaddr_get(port_id: u8, mac_addr: *mut ether_addr);
}
extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dev_info"]
    #[doc = "   A pointer to a structure of type *rte_eth_dev_info* to be filled with"]
    #[doc = "   the contextual information of the Ethernet device."]
    pub fn rte_eth_dev_info_get(port_id: u8, dev_info: *mut rte_eth_dev_info);
}
extern "C" {
    #[doc = " Retrieve the firmware version of a device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the device."]
    #[doc = " @param fw_version"]
    #[doc = "   A pointer to a string array storing the firmware version of a device,"]
    #[doc = "   the string includes terminating null. This pointer is allocated by caller."]
    #[doc = " @param fw_size"]
    #[doc = "   The size of the string array pointed by fw_version, which should be"]
    #[doc = "   large enough to store firmware version of the device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (>0) if *fw_size* is not enough to store firmware version, return"]
    #[doc = "          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u8,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device."]
    #[doc = ""]
    #[doc = " When a packet type is announced as supported, it *must* be recognized by"]
    #[doc = " the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = " and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following"]
    #[doc = " packet types for these packets:"]
    #[doc = " - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4"]
    #[doc = " - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER"]
    #[doc = " - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN"]
    #[doc = ""]
    #[doc = " When a packet is received by a PMD, the most precise type must be"]
    #[doc = " returned among the ones supported. However a PMD is allowed to set"]
    #[doc = " packet type that is not in the supported list, at the condition that it"]
    #[doc = " is more precise. Therefore, a PMD announcing no supported packet types"]
    #[doc = " can still set a matching packet type in a received packet."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Better to invoke this API after the device is already started or rx burst"]
    #[doc = "   function is decided, to obtain correct supported ptypes."]
    #[doc = " @note"]
    #[doc = "   if a given PMD does not report what ptypes it supports, then the supported"]
    #[doc = "   ptype count is reported as 0."]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param ptype_mask"]
    #[doc = "   A hint of what kind of packet type which the caller is interested in."]
    #[doc = " @param ptypes"]
    #[doc = "   An array pointer to store adequate packet types, allocated by caller."]
    #[doc = " @param num"]
    #[doc = "  Size of the array pointed by param ptypes."]
    #[doc = " @return"]
    #[doc = "   - (>=0) Number of supported ptypes. If the number of types exceeds num,"]
    #[doc = "           only num entries will be filled into the ptypes array, but the full"]
    #[doc = "           count of supported ptypes will be returned."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u8,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A pointer to a uint16_t where the retrieved MTU is to be stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_mtu(port_id: u8, mtu: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the MTU of an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mtu"]
    #[doc = "   A uint16_t for the MTU to be applied."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if operation is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *mtu* invalid."]
    #[doc = "   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u8, mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received"]
    #[doc = " VLAN packets tagged with a given VLAN Tag Identifier."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_id"]
    #[doc = "   The VLAN Tag Identifier whose filtering must be enabled or disabled."]
    #[doc = " @param on"]
    #[doc = "   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = "   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOSYS) if VLAN filtering on *port_id* disabled."]
    #[doc = "   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(
        port_id: u8,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device."]
    #[doc = " 82599/X540/X550 can support VLAN stripping at the rx queue level"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rx_queue_id"]
    #[doc = "   The index of the receive queue for which a queue stats mapping is required."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param on"]
    #[doc = "   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = "   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN stripping not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u8,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to"]
    #[doc = " the VLAN Header. This is a register setup available on some Intel NIC, not"]
    #[doc = " but all, please check the data sheet for availability."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param vlan_type"]
    #[doc = "   The vlan type."]
    #[doc = " @param tag_type"]
    #[doc = "   The Tag Protocol ID"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN TPID setup is not supported."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u8,
        vlan_type: rte_vlan_type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device"]
    #[doc = " Enable/Disable Extended VLAN by an Ethernet device, This is a register setup"]
    #[doc = " available on some Intel NIC, not but all, please check the data sheet for"]
    #[doc = " availability."]
    #[doc = " Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here"]
    #[doc = " the configuration is applied on the port level."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param offload_mask"]
    #[doc = "   The VLAN Offload bit mask can be mixed use with \"OR\""]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOSUP) if hardware-assisted VLAN filtering not configured."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u8,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>0) if successful. Bit mask to indicate"]
    #[doc = "       ETH_VLAN_STRIP_OFFLOAD"]
    #[doc = "       ETH_VLAN_FILTER_OFFLOAD"]
    #[doc = "       ETH_VLAN_EXTEND_OFFLOAD"]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set port based TX VLAN insertion on or off."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  The port identifier of the Ethernet device."]
    #[doc = " @param pvid"]
    #[doc = "  Port based TX VLAN identifier together with user priority."]
    #[doc = " @param on"]
    #[doc = "  Turn on or off the port based TX VLAN insertion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u8,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Structure used to buffer packets for future TX"]
#[doc = " Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_tx_buffer() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_tx_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(rte_eth_dev_tx_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_tx_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_tx_buffer))
    );
}
extern "C" {
    #[doc = " Initialize default values for buffered transmitting"]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   Tx buffer to be initialized."]
    #[doc = " @param size"]
    #[doc = "   Buffer size"]
    #[doc = " @return"]
    #[doc = "   0 if no error"]
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent"]
    #[doc = ""]
    #[doc = " Register a specific callback to be called when an attempt is made to send"]
    #[doc = " all packets buffered on an ethernet port, but not all packets can"]
    #[doc = " successfully be sent. The callback registered here will be called only"]
    #[doc = " from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs."]
    #[doc = " The default callback configured for each queue by default just frees the"]
    #[doc = " packets back to the calling mempool. If additional behaviour is required,"]
    #[doc = " for example, to count dropped packets, or to retry transmission of packets"]
    #[doc = " which cannot be sent, this function should be used to register a suitable"]
    #[doc = " callback function to implement the desired behaviour."]
    #[doc = " The example callback \"rte_eth_count_unsent_packet_callback()\" is also"]
    #[doc = " provided as reference."]
    #[doc = ""]
    #[doc = " @param buffer"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param callback"]
    #[doc = "   The function to be used as the callback."]
    #[doc = " @param userdata"]
    #[doc = "   Arbitrary parameter to be passed to the callback function"]
    #[doc = " @return"]
    #[doc = "   0 on success, or -1 on error with rte_errno set appropriately"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets silently and is used by tx buffered"]
    #[doc = " operations as default behavior."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets."]
    #[doc = ""]
    #[doc = " This function can be passed to rte_eth_tx_buffer_set_err_callback() to"]
    #[doc = " adjust the default behavior when buffered packets cannot be sent. This"]
    #[doc = " function drops any unsent packets, but also updates a user-supplied counter"]
    #[doc = " to track the overall number of packets dropped. The counter should be an"]
    #[doc = " uint64_t variable."]
    #[doc = ""]
    #[doc = " NOTE: this function should not be called directly, instead it should be used"]
    #[doc = "       as a callback for packet buffering."]
    #[doc = ""]
    #[doc = " NOTE: when configuring this function as a callback with"]
    #[doc = "       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter"]
    #[doc = "       should point to an uint64_t value."]
    #[doc = ""]
    #[doc = " @param pkts"]
    #[doc = "   The previously buffered packets which could not be sent"]
    #[doc = " @param unsent"]
    #[doc = "   The number of unsent packets in the pkts array"]
    #[doc = " @param userdata"]
    #[doc = "   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The"]
    #[doc = " driver will only free the mbuf if it is no longer in use. It is the"]
    #[doc = " application's responsibity to ensure rte_eth_tx_buffer_flush(..) is"]
    #[doc = " called if needed."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the transmit queue through which output packets must be"]
    #[doc = "   sent."]
    #[doc = "   The value must be in the range [0, nb_tx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param free_cnt"]
    #[doc = "   Maximum number of packets to free. Use 0 to indicate all possible packets"]
    #[doc = "   should be freed. Note that a packet may be using multiple mbufs."]
    #[doc = " @return"]
    #[doc = "   Failure: < 0"]
    #[doc = "     -ENODEV: Invalid interface"]
    #[doc = "     -ENOTSUP: Driver does not support function"]
    #[doc = "   Success: >= 0"]
    #[doc = "     0-n: Number of packets freed. More packets may still remain in ring that"]
    #[doc = "     are in use."]
    pub fn rte_eth_tx_done_cleanup(
        port_id: u8,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< unknown event type"]
pub const rte_eth_event_type_RTE_ETH_EVENT_UNKNOWN: rte_eth_event_type = 0;
#[doc = "< lsc interrupt event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_LSC: rte_eth_event_type = 1;
pub const rte_eth_event_type_RTE_ETH_EVENT_QUEUE_STATE: rte_eth_event_type = 2;
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RESET: rte_eth_event_type = 3;
#[doc = "< message from the VF received by PF"]
pub const rte_eth_event_type_RTE_ETH_EVENT_VF_MBOX: rte_eth_event_type = 4;
#[doc = "< MACsec offload related event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MACSEC: rte_eth_event_type = 5;
#[doc = "< device removal event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RMV: rte_eth_event_type = 6;
#[doc = "< max value of this enum"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MAX: rte_eth_event_type = 7;
#[doc = " The eth device event type for interrupt, and maybe others in the future."]
pub type rte_eth_event_type = u32;
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u8,
        event: rte_eth_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register a callback function for specific port id."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port id."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_register(
        port_id: u8,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a callback function for specific port id."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "  Port id."]
    #[doc = " @param event"]
    #[doc = "  Event interested."]
    #[doc = " @param cb_fn"]
    #[doc = "  User supplied callback function to be called."]
    #[doc = " @param cb_arg"]
    #[doc = "  Pointer to the parameters for the registered callback. -1 means to"]
    #[doc = "  remove all for the same callback address and same event."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, zero."]
    #[doc = "  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_unregister(
        port_id: u8,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal Executes all the user application registered callbacks for"]
    #[doc = " the specific device. It is for DPDK internal user only. User"]
    #[doc = " application should not call it directly."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "  Pointer to struct rte_eth_dev."]
    #[doc = " @param event"]
    #[doc = "  Eth device interrupt event type."]
    #[doc = " @param cb_arg"]
    #[doc = "  callback parameter."]
    #[doc = " @param ret_param"]
    #[doc = "  To pass data back to user application."]
    #[doc = "  This allows the user application to decide if a particular function"]
    #[doc = "  is permitted or not."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  int"]
    pub fn _rte_eth_dev_callback_process(
        dev: *mut rte_eth_dev,
        event: rte_eth_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When there is no rx packet coming in Rx Queue for a long time, we can"]
    #[doc = " sleep lcore related to RX Queue for power saving, and enable rx interrupt"]
    #[doc = " to be triggered when Rx packet arrives."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_enable() function enables rx queue"]
    #[doc = " interrupt on specific rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_rx_intr_enable(port_id: u8, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When lcore wakes up from rx interrupt indicating packet coming, disable rx"]
    #[doc = " interrupt and returns to polling mode."]
    #[doc = ""]
    #[doc = " The rte_eth_dev_rx_intr_disable() function disables rx queue"]
    #[doc = " interrupt on specific rx queue of a port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_rx_intr_disable(port_id: u8, queue_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RX Interrupt control per port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u8,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RX Interrupt control per queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the receive queue from which to retrieve input packets."]
    #[doc = "   The value must be in the range [0, nb_rx_queue - 1] previously supplied"]
    #[doc = "   to rte_eth_dev_configure()."]
    #[doc = " @param epfd"]
    #[doc = "   Epoll instance fd which the intr vector associated to."]
    #[doc = "   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance."]
    #[doc = " @param op"]
    #[doc = "   The operation be performed for the vector."]
    #[doc = "   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}."]
    #[doc = " @param data"]
    #[doc = "   User raw data."]
    #[doc = " @return"]
    #[doc = "   - On success, zero."]
    #[doc = "   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u8,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn on the LED on the Ethernet device."]
    #[doc = " This function turns on the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_led_on(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn off the LED on the Ethernet device."]
    #[doc = " This function turns off the LED on the Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if underlying hardware OR driver doesn't support"]
    #[doc = "     that operation."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_led_off(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current status of the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure where to store the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u8,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet link flow control for Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param fc_conf"]
    #[doc = "   The pointer to the structure of the flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure"]
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u8,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Ethernet priority flow control under DCB environment"]
    #[doc = " for Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = " The port identifier of the Ethernet device."]
    #[doc = " @param pfc_conf"]
    #[doc = " The pointer to the structure of the priority flow control parameters."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support priority flow control mode."]
    #[doc = "   - (-ENODEV)  if *port_id* invalid."]
    #[doc = "   - (-EINVAL)  if bad parameter"]
    #[doc = "   - (-EIO)     if flow control setup failure"]
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u8,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a MAC address to an internal array of addresses used to enable whitelist"]
    #[doc = " filtering to accept packets only if the destination MAC address matches."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   The MAC address to add."]
    #[doc = " @param pool"]
    #[doc = "   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is"]
    #[doc = "   not enabled, this should be set to 0."]
    #[doc = " @return"]
    #[doc = "   - (0) if successfully added or *mac_addr\" was already added."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port* is invalid."]
    #[doc = "   - (-ENOSPC) if no more MAC addresses can be added."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_add(
        port: u8,
        mac_addr: *mut ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a MAC address from the internal array of addresses."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   MAC address to remove."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EADDRINUSE) if attempting to remove the default MAC address"]
    pub fn rte_eth_dev_mac_addr_remove(
        port: u8,
        mac_addr: *mut ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default MAC address."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mac_addr"]
    #[doc = "   New default MAC address."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful, or *mac_addr* didn't exist."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port* invalid."]
    #[doc = "   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_default_mac_addr_set(
        port: u8,
        mac_addr: *mut ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to update."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_reta_update(
        port: u8,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param reta_conf"]
    #[doc = "   RETA to query."]
    #[doc = " @param reta_size"]
    #[doc = "   Redirection table size. The table size can be queried by"]
    #[doc = "   rte_eth_dev_info_get()."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_reta_query(
        port: u8,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates unicast hash table for receiving packet with the given destination"]
    #[doc = " MAC address, and the packet is routed to all VFs for which the RX mode is"]
    #[doc = " accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param addr"]
    #[doc = "   Unicast MAC address."]
    #[doc = " @param on"]
    #[doc = "    1 - Set an unicast hash bit for receiving packets with the MAC address."]
    #[doc = "    0 - Clear an unicast hash bit."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_hash_table_set(
        port: u8,
        addr: *mut ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Updates all unicast hash bitmaps for receiving packet with any Unicast"]
    #[doc = " Ethernet MAC addresses,the packet is routed to all VFs for which the RX"]
    #[doc = " mode is accept packets that match the unicast hash table."]
    #[doc = ""]
    #[doc = " @param port"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param on"]
    #[doc = "    1 - Set all unicast hash bitmaps for receiving all the Ethernet"]
    #[doc = "         MAC addresses"]
    #[doc = "    0 - Clear all unicast hash bitmaps"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "  - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_all_hash_table_set(port: u8, on: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a traffic mirroring rule on an Ethernet device"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mirror_conf"]
    #[doc = "   The pointer to the traffic mirroring structure describing the mirroring rule."]
    #[doc = "   The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,"]
    #[doc = "   destination pool and the value of rule if enable vlan or pool mirroring."]
    #[doc = ""]
    #[doc = " @param rule_id"]
    #[doc = "   The index of traffic mirroring rule, we support four separated rules."]
    #[doc = " @param on"]
    #[doc = "   1 - Enable a mirroring rule."]
    #[doc = "   0 - Disable a mirroring rule."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if the mr_conf information is not correct."]
    pub fn rte_eth_mirror_rule_set(
        port_id: u8,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset a traffic mirroring rule on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rule_id"]
    #[doc = "   The index of traffic mirroring rule, we support four separated rules."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_mirror_rule_reset(port_id: u8, rule_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the rate limitation for a queue on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_idx"]
    #[doc = "   The queue id."]
    #[doc = " @param tx_rate"]
    #[doc = "   The tx rate in Mbps. Allocated from the total port link speed."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this feature."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u8,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configuration of Receive Side Scaling hash computation of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   The new configuration to use for RSS hash computation on the port."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u8,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve current configuration of Receive Side Scaling hash computation"]
    #[doc = " of Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param rss_conf"]
    #[doc = "   Where to store the current RSS hash configuration of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support RSS."]
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u8,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add UDP tunneling port for a specific type of tunnel."]
    #[doc = " The packets with this UDP port will be identified as this type of tunnel."]
    #[doc = " Before enabling any offloading function for a tunnel, users can call this API"]
    #[doc = " to change or add more UDP port for the tunnel. So the offloading function"]
    #[doc = " can take effect on the packets with the specific UDP port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u8,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete UDP tunneling port a specific type of tunnel."]
    #[doc = " The packets with this UDP port will not be identified as this type of tunnel"]
    #[doc = " any more."]
    #[doc = " Before enabling any offloading function for a tunnel, users can call this API"]
    #[doc = " to delete a UDP port for the tunnel. So the offloading function will not take"]
    #[doc = " effect on the packets with the specific UDP port."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param tunnel_udp"]
    #[doc = "   UDP tunneling configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u8,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether the filter type is supported on an Ethernet device."]
    #[doc = " All the supported filter types are defined in 'rte_eth_ctrl.h'."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param filter_type"]
    #[doc = "   Filter type."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support this filter type."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_filter_supported(
        port_id: u8,
        filter_type: rte_filter_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Take operations to assigned filter type on an Ethernet device."]
    #[doc = " All the supported operations and filter types are defined in 'rte_eth_ctrl.h'."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param filter_type"]
    #[doc = "   Filter type."]
    #[doc = " @param filter_op"]
    #[doc = "   Type of operation."]
    #[doc = " @param arg"]
    #[doc = "   A pointer to arguments defined specifically for the operation."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_filter_ctrl(
        port_id: u8,
        filter_type: rte_filter_type,
        filter_op: rte_filter_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get DCB information on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param dcb_info"]
    #[doc = "   dcb information."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u8,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a callback to be called on packet RX on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_rx_callback(
        port_id: u8,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Add a callback that must be called first on packet RX on a given port"]
    #[doc = " and queue."]
    #[doc = ""]
    #[doc = " This API configures a first function to be called for each burst of"]
    #[doc = " packets received on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_rx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_first_rx_callback(
        port_id: u8,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Add a callback to be called on packet TX on a given port and queue."]
    #[doc = ""]
    #[doc = " This API configures a function to be called for each burst of"]
    #[doc = " packets sent on a given NIC port queue. The return value is a pointer"]
    #[doc = " that can be used to later remove the callback using"]
    #[doc = " rte_eth_remove_tx_callback()."]
    #[doc = ""]
    #[doc = " Multiple functions are called in the order that they are added."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device on which the callback is to be added."]
    #[doc = " @param fn"]
    #[doc = "   The callback function"]
    #[doc = " @param user_param"]
    #[doc = "   A generic pointer parameter which will be passed to each invocation of the"]
    #[doc = "   callback function on this port and queue."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   NULL on error."]
    #[doc = "   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_tx_callback(
        port_id: u8,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove an RX packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing RX/TX"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_rx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The port_id or the queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_rx_callback(
        port_id: u8,
        queue_id: u16,
        user_cb: *mut rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a TX packet callback from a given port and queue."]
    #[doc = ""]
    #[doc = " This function is used to removed callbacks that were added to a NIC port"]
    #[doc = " queue using rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " Note: the callback is removed from the callback list but it isn't freed"]
    #[doc = " since the it may still be in use. The memory for the callback can be"]
    #[doc = " subsequently freed back by the application by calling rte_free():"]
    #[doc = ""]
    #[doc = " - Immediately - if the port is stopped, or the user knows that no"]
    #[doc = "   callbacks are in flight e.g. if called from the thread doing RX/TX"]
    #[doc = "   on that queue."]
    #[doc = ""]
    #[doc = " - After a short delay - where the delay is sufficient to allow any"]
    #[doc = "   in-flight callbacks to complete."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The queue on the Ethernet device from which the callback is to be removed."]
    #[doc = " @param user_cb"]
    #[doc = "   User supplied callback created via rte_eth_add_tx_callback()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success. Callback was removed."]
    #[doc = "   - -ENOTSUP: Callback support is not available."]
    #[doc = "   - -EINVAL:  The port_id or the queue_id is out of range, or the callback"]
    #[doc = "               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_tx_callback(
        port_id: u8,
        queue_id: u16,
        user_cb: *mut rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's RX queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The RX queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The port_id or the queue_id is out of range."]
    pub fn rte_eth_rx_queue_info_get(
        port_id: u8,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about given port's TX queue."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param queue_id"]
    #[doc = "   The TX queue on the Ethernet device for which information"]
    #[doc = "   will be retrieved."]
    #[doc = " @param qinfo"]
    #[doc = "   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with"]
    #[doc = "   the information of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success"]
    #[doc = "   - -ENOTSUP: routine is not supported by the device PMD."]
    #[doc = "   - -EINVAL:  The port_id or the queue_id is out of range."]
    pub fn rte_eth_tx_queue_info_get(
        port_id: u8,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve device registers and register attributes (number of registers and"]
    #[doc = " register size)"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   Pointer to rte_dev_reg_info structure to fill in. If info->data is"]
    #[doc = "   NULL the function fills in the width and length fields. If non-NULL"]
    #[doc = "   the registers are put into the buffer pointed at by the data field."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info(
        port_id: u8,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve size of device EEPROM"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @return"]
    #[doc = "   - (>=0) EEPROM size if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom_length(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve EEPROM and EEPROM attribute"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes buffer for return EEPROM data and"]
    #[doc = "   EEPROM attributes to be filled."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom(
        port_id: u8,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Program EEPROM with provided data"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param info"]
    #[doc = "   The template includes EEPROM data for programming and"]
    #[doc = "   EEPROM attributes to be filled"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_set_eeprom(
        port_id: u8,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the list of multicast addresses to filter on an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param mc_addr_set"]
    #[doc = "   The array of multicast addresses to set. Equal to NULL when the function"]
    #[doc = "   is invoked to flush the set of filtered addresses."]
    #[doc = " @param nb_mc_addr"]
    #[doc = "   The number of multicast addresses in the *mc_addr_set* array. Equal to 0"]
    #[doc = "   when the function is invoked to flush the set of filtered addresses."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if *port_id* invalid."]
    #[doc = "   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering."]
    #[doc = "   - (-ENOSPC) if *port_id* has not enough multicast filtering resources."]
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u8,
        mc_addr_set: *mut ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_enable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable IEEE1588/802.1AS timestamping for an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_disable(port_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS RX timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = " @param flags"]
    #[doc = "   Device specific flags. Used to pass the RX timesync register index to"]
    #[doc = "   i40e. Unused in igb/ixgbe, pass 0 instead."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u8,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an IEEE1588/802.1AS TX timestamp from an Ethernet device."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param timestamp"]
    #[doc = "   Pointer to the timestamp struct."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u8,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param delta"]
    #[doc = "   The adjustment in nanoseconds."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_time(port_id: u8, delta: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the time from the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    pub fn rte_eth_timesync_read_time(port_id: u8, time: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the time of the timesync clock on an Ethernet device."]
    #[doc = ""]
    #[doc = " This is usually used in conjunction with other Ethdev timesync functions to"]
    #[doc = " synchronize the device time using the IEEE1588/802.1AS protocol."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param time"]
    #[doc = "   Pointer to the timespec struct that holds the time."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0: Success."]
    #[doc = "   - -EINVAL: No timestamp is available."]
    #[doc = "   - -ENODEV: The port ID is invalid."]
    #[doc = "   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_write_time(port_id: u8, time: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create memzone for HW rings."]
    #[doc = " malloc can't be used as the physical address is needed."]
    #[doc = " If the memzone is already created, then this function returns a ptr"]
    #[doc = " to the old one."]
    #[doc = ""]
    #[doc = " @param eth_dev"]
    #[doc = "   The *eth_dev* pointer is the address of the *rte_eth_dev* structure"]
    #[doc = " @param name"]
    #[doc = "   The name of the memory zone"]
    #[doc = " @param queue_id"]
    #[doc = "   The index of the queue to add to name"]
    #[doc = " @param size"]
    #[doc = "   The sizeof of the memory area"]
    #[doc = " @param align"]
    #[doc = "   Alignment for resulting memzone. Must be a power of 2."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in case of NUMA."]
    pub fn rte_eth_dma_zone_reserve(
        eth_dev: *const rte_eth_dev,
        name: *const ::std::os::raw::c_char,
        queue_id: u16,
        size: usize,
        align: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
    ) -> *const rte_memzone;
}
extern "C" {
    #[doc = " Config l2 tunnel ether type of an Ethernet device for filtering specific"]
    #[doc = " tunnel packets by ether type."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param l2_tunnel"]
    #[doc = "   l2 tunnel configuration."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(
        port_id: u8,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/disable l2 tunnel offload functions. Include,"]
    #[doc = " 1, The ability of parsing a type of l2 tunnel of an Ethernet device."]
    #[doc = "    Filtering, forwarding and offloading this type of tunnel packets depend on"]
    #[doc = "    this ability."]
    #[doc = " 2, Stripping the l2 tunnel tag."]
    #[doc = " 3, Insertion of the l2 tunnel tag."]
    #[doc = " 4, Forwarding the packets based on the l2 tunnel tag."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param l2_tunnel"]
    #[doc = "   l2 tunnel parameters."]
    #[doc = " @param mask"]
    #[doc = "   Indicate the offload function."]
    #[doc = " @param en"]
    #[doc = "   Enable or disable this function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENODEV) if port identifier is invalid."]
    #[doc = "   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_l2_tunnel_offload_set(
        port_id: u8,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the port id from pci address or device name"]
    #[doc = " Ex: 0000:2:00.0 or vdev name net_pcap0"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "  pci address or name of the device"]
    #[doc = " @param port_id"]
    #[doc = "   pointer to port identifier of the device"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful and port_id is filled."]
    #[doc = "   - (-ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the device name from port id"]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   pointer to port identifier of the device"]
    #[doc = " @param name"]
    #[doc = "  pci address or name of the device"]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-EINVAL) on failure."]
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u8,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check that numbers of Rx and Tx descriptors satisfy descriptors limits from"]
    #[doc = " the ethernet device information, otherwise adjust them to boundaries."]
    #[doc = ""]
    #[doc = " @param port_id"]
    #[doc = "   The port identifier of the Ethernet device."]
    #[doc = " @param nb_rx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of receive"]
    #[doc = "   descriptors stored."]
    #[doc = " @param nb_tx_desc"]
    #[doc = "   A pointer to a uint16_t where the number of transmit"]
    #[doc = "   descriptors stored."]
    #[doc = " @return"]
    #[doc = "   - (0) if successful."]
    #[doc = "   - (-ENOTSUP, -ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u8,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
pub const rte_timer_type_SINGLE: rte_timer_type = 0;
pub const rte_timer_type_PERIODICAL: rte_timer_type = 1;
#[doc = " Timer type: Periodic or single (one-shot)."]
pub type rte_timer_type = u32;
#[doc = " Timer status: A union of the state (stopped, pending, running,"]
#[doc = " config) and an owner (the id of the lcore that owns the timer)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_timer_status {
    pub __bindgen_anon_1: rte_timer_status__bindgen_ty_1,
    #[doc = "< To atomic-set status + owner."]
    pub u32: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_timer_status__bindgen_ty_1 {
    #[doc = "< Stop, pending, running, config."]
    pub state: u16,
    #[doc = "< The lcore that owns the timer."]
    pub owner: i16,
}
#[test]
fn bindgen_test_layout_rte_timer_status__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_timer_status__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_timer_status__bindgen_ty_1>())).owner as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_timer_status() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer_status>(),
        4usize,
        concat!("Size of: ", stringify!(rte_timer_status))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer_status>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_timer_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer_status>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer_status),
            "::",
            stringify!(u32)
        )
    );
}
#[doc = " Callback function type for timer expiry."]
pub type rte_timer_cb_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_timer, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A structure describing a timer in RTE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_timer {
    #[doc = "< Time when timer expire."]
    pub expire: u64,
    pub sl_next: [*mut rte_timer; 10usize],
    #[doc = "< Status of timer."]
    pub status: rte_timer_status,
    #[doc = "< Period of timer (0 if not periodic)."]
    pub period: u64,
    #[doc = "< Callback function."]
    pub f: rte_timer_cb_t,
    #[doc = "< Argument to callback function."]
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_timer() {
    assert_eq!(
        ::std::mem::size_of::<rte_timer>(),
        120usize,
        concat!("Size of: ", stringify!(rte_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).expire as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).sl_next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(sl_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).status as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).period as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).f as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_timer>())).arg as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_timer),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    #[doc = " Initialize the timer library."]
    #[doc = ""]
    #[doc = " Initializes internal variables (list, locks and so on) for the RTE"]
    #[doc = " timer library."]
    pub fn rte_timer_subsystem_init();
}
extern "C" {
    #[doc = " Initialize a timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_init() function initializes the timer handle *tim*"]
    #[doc = " for use. No operations can be performed on a timer before it is"]
    #[doc = " initialized."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer to initialize."]
    pub fn rte_timer_init(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Reset and start the timer associated with the timer handle."]
    #[doc = ""]
    #[doc = " The rte_timer_reset() function resets and starts the timer"]
    #[doc = " associated with the timer handle *tim*. When the timer expires after"]
    #[doc = " *ticks* HPET cycles, the function specified by *fct* will be called"]
    #[doc = " with the argument *arg* on core *tim_lcore*."]
    #[doc = ""]
    #[doc = " If the timer associated with the timer handle is already running"]
    #[doc = " (in the RUNNING state), the function will fail. The user has to check"]
    #[doc = " the return value of the function to see if there is a chance that the"]
    #[doc = " timer is in the RUNNING state."]
    #[doc = ""]
    #[doc = " If the timer is being configured on another core (the CONFIG state),"]
    #[doc = " it will also fail."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped, it will be rescheduled with the"]
    #[doc = " new parameters."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is scheduled."]
    #[doc = "   - (-1): Timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_reset(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_reset() succeeds."]
    #[doc = ""]
    #[doc = " Reset and start the timer associated with the timer handle. Always"]
    #[doc = " succeed. See rte_timer_reset() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @param ticks"]
    #[doc = "   The number of cycles (see rte_get_hpet_hz()) before the callback"]
    #[doc = "   function is called."]
    #[doc = " @param type"]
    #[doc = "   The type can be either:"]
    #[doc = "   - PERIODICAL: The timer is automatically reloaded after execution"]
    #[doc = "     (returns to the PENDING state)"]
    #[doc = "   - SINGLE: The timer is one-shot, that is, the timer goes to a"]
    #[doc = "     STOPPED state after execution."]
    #[doc = " @param tim_lcore"]
    #[doc = "   The ID of the lcore where the timer callback function has to be"]
    #[doc = "   executed. If tim_lcore is LCORE_ID_ANY, the timer library will"]
    #[doc = "   launch it on a different core for each call (round-robin)."]
    #[doc = " @param fct"]
    #[doc = "   The callback function of the timer."]
    #[doc = " @param arg"]
    #[doc = "   The user argument of the callback function."]
    pub fn rte_timer_reset_sync(
        tim: *mut rte_timer,
        ticks: u64,
        type_: rte_timer_type,
        tim_lcore: ::std::os::raw::c_uint,
        fct: rte_timer_cb_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Stop a timer."]
    #[doc = ""]
    #[doc = " The rte_timer_stop() function stops the timer associated with the"]
    #[doc = " timer handle *tim*. It may fail if the timer is currently running or"]
    #[doc = " being configured."]
    #[doc = ""]
    #[doc = " If the timer is pending or stopped (for instance, already expired),"]
    #[doc = " the function will succeed. The timer handle tim must have been"]
    #[doc = " initialized using rte_timer_init(), otherwise, undefined behavior"]
    #[doc = " will occur."]
    #[doc = ""]
    #[doc = " This function can be called safely from a timer callback. If it"]
    #[doc = " succeeds, the timer is not referenced anymore by the timer library"]
    #[doc = " and the timer structure can be freed (even in the callback"]
    #[doc = " function)."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the timer is stopped."]
    #[doc = "   - (-1): The timer is in the RUNNING or CONFIG state."]
    pub fn rte_timer_stop(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loop until rte_timer_stop() succeeds."]
    #[doc = ""]
    #[doc = " After a call to this function, the timer identified by *tim* is"]
    #[doc = " stopped. See rte_timer_stop() for details."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    pub fn rte_timer_stop_sync(tim: *mut rte_timer);
}
extern "C" {
    #[doc = " Test if a timer is pending."]
    #[doc = ""]
    #[doc = " The rte_timer_pending() function tests the PENDING status"]
    #[doc = " of the timer handle *tim*. A PENDING timer is one that has been"]
    #[doc = " scheduled and whose function has not yet been called."]
    #[doc = ""]
    #[doc = " @param tim"]
    #[doc = "   The timer handle."]
    #[doc = " @return"]
    #[doc = "   - 0: The timer is not pending."]
    #[doc = "   - 1: The timer is pending."]
    pub fn rte_timer_pending(tim: *mut rte_timer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Manage the timer list and execute callback functions."]
    #[doc = ""]
    #[doc = " This function must be called periodically from EAL lcores"]
    #[doc = " main_loop(). It browses the list of pending timers and runs all"]
    #[doc = " timers that are expired."]
    #[doc = ""]
    #[doc = " The precision of the timer depends on the call frequency of this"]
    #[doc = " function. However, the more often the function is called, the more"]
    #[doc = " CPU resources it will use."]
    pub fn rte_timer_manage();
}
extern "C" {
    #[doc = " Dump statistics about timers."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_timer_dump_stats(f: *mut FILE);
}
extern "C" {
    #[doc = " Pathname of PCI devices directory."]
    pub fn pci_get_sysfs_path() -> *const ::std::os::raw::c_char;
}
#[doc = " List of PCI devices"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_device_list {
    pub tqh_first: *mut rte_pci_device,
    pub tqh_last: *mut *mut rte_pci_device,
}
#[test]
fn bindgen_test_layout_rte_pci_device_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_device_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_pci_device_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_device_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_device_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[doc = " List of PCI drivers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_driver_list {
    pub tqh_first: *mut rte_pci_driver,
    pub tqh_last: *mut *mut rte_pci_driver,
}
#[test]
fn bindgen_test_layout_rte_pci_driver_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_driver_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_pci_driver_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_driver_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_driver_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[doc = " A structure describing an ID for a PCI driver. Each driver provides a"]
#[doc = " table of these IDs for each device that it supports."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_id {
    #[doc = "< Class ID (class, subclass, pi) or RTE_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or PCI_ANY_ID."]
    pub subsystem_vendor_id: u16,
    #[doc = "< Subsystem device ID or PCI_ANY_ID."]
    pub subsystem_device_id: u16,
}
#[test]
fn bindgen_test_layout_rte_pci_id() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_id>(),
        12usize,
        concat!("Size of: ", stringify!(rte_pci_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).class_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).vendor_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).device_id as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_vendor_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_id>())).subsystem_device_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_id),
            "::",
            stringify!(subsystem_device_id)
        )
    );
}
#[doc = " A structure describing the location of a PCI device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_addr {
    #[doc = "< Device domain"]
    pub domain: u32,
    #[doc = "< Device bus"]
    pub bus: u8,
    #[doc = "< Device ID"]
    pub devid: u8,
    #[doc = "< Device function."]
    pub function: u8,
}
#[test]
fn bindgen_test_layout_rte_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pci_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).bus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).devid as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(devid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_addr>())).function as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_addr),
            "::",
            stringify!(function)
        )
    );
}
#[doc = " A structure describing a PCI device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_pci_device {
    #[doc = "< Next probed PCI device."]
    pub next: rte_pci_device__bindgen_ty_1,
    #[doc = "< Inherit core device"]
    pub device: rte_device,
    #[doc = "< PCI location."]
    pub addr: rte_pci_addr,
    #[doc = "< PCI ID."]
    pub id: rte_pci_id,
    pub mem_resource: [rte_mem_resource; 6usize],
    #[doc = "< Interrupt handle"]
    pub intr_handle: rte_intr_handle,
    #[doc = "< Associated driver"]
    pub driver: *mut rte_pci_driver,
    #[doc = "< sriov enable if not zero"]
    pub max_vfs: u16,
    #[doc = "< Kernel driver passthrough"]
    pub kdrv: rte_kernel_driver,
    #[doc = "< PCI location (ASCII)"]
    pub name: [::std::os::raw::c_char; 18usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_device,
    pub tqe_prev: *mut *mut rte_pci_device,
}
#[test]
fn bindgen_test_layout_rte_pci_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_pci_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pci_device__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pci_device__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_pci_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_device>(),
        1968usize,
        concat!("Size of: ", stringify!(rte_pci_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).device as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).addr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).mem_resource as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(mem_resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).intr_handle as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(intr_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).driver as *const _ as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).max_vfs as *const _ as usize },
        1936usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).kdrv as *const _ as usize },
        1940usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(kdrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_device>())).name as *const _ as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_device),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " Initialisation function for the driver called during PCI probing."]
pub type pci_probe_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut rte_pci_driver,
        arg2: *mut rte_pci_device,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Uninitialisation function for the driver called during hotplugging."]
pub type pci_remove_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut rte_pci_device) -> ::std::os::raw::c_int>;
#[doc = " A structure describing a PCI driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_driver {
    #[doc = "< Next in list."]
    pub next: rte_pci_driver__bindgen_ty_1,
    #[doc = "< Inherit core driver."]
    pub driver: rte_driver,
    #[doc = "< PCI bus reference."]
    pub bus: *mut rte_pci_bus,
    #[doc = "< Device Probe function."]
    pub probe: pci_probe_t,
    #[doc = "< Device Remove function."]
    pub remove: pci_remove_t,
    #[doc = "< ID table, NULL terminated."]
    pub id_table: *const rte_pci_id,
    #[doc = "< Flags contolling handling of device."]
    pub drv_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_pci_driver,
    pub tqe_prev: *mut *mut rte_pci_driver,
}
#[test]
fn bindgen_test_layout_rte_pci_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_pci_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pci_driver__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_pci_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_pci_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_driver>(),
        88usize,
        concat!("Size of: ", stringify!(rte_pci_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).driver as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).bus as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).probe as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).remove as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).id_table as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(id_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_driver>())).drv_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_driver),
            "::",
            stringify!(drv_flags)
        )
    );
}
#[doc = " Structure describing the PCI bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_bus {
    #[doc = "< Inherit the generic class"]
    pub bus: rte_bus,
    #[doc = "< List of PCI devices"]
    pub device_list: rte_pci_device_list,
    #[doc = "< List of PCI drivers"]
    pub driver_list: rte_pci_driver_list,
}
#[test]
fn bindgen_test_layout_rte_pci_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_bus>(),
        112usize,
        concat!("Size of: ", stringify!(rte_pci_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_bus>())).bus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_bus),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_bus>())).device_list as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_bus),
            "::",
            stringify!(device_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_bus>())).driver_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_bus),
            "::",
            stringify!(driver_list)
        )
    );
}
#[doc = " A structure describing a PCI mapping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_map {
    pub addr: *mut ::std::os::raw::c_void,
    pub path: *mut ::std::os::raw::c_char,
    pub offset: u64,
    pub size: u64,
    pub phaddr: u64,
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(
        ::std::mem::size_of::<pci_map>(),
        40usize,
        concat!("Size of: ", stringify!(pci_map))
    );
    assert_eq!(
        ::std::mem::align_of::<pci_map>(),
        8usize,
        concat!("Alignment of ", stringify!(pci_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pci_map>())).phaddr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pci_map),
            "::",
            stringify!(phaddr)
        )
    );
}
#[doc = " A structure describing a mapped PCI resource."]
#[doc = " For multi-process we need to reproduce all PCI mappings in secondary"]
#[doc = " processes, so save them in a tailq."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mapped_pci_resource {
    pub next: mapped_pci_resource__bindgen_ty_1,
    pub pci_addr: rte_pci_addr,
    pub path: [::std::os::raw::c_char; 4096usize],
    pub nb_maps: ::std::os::raw::c_int,
    pub maps: [pci_map; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mapped_pci_resource__bindgen_ty_1 {
    pub tqe_next: *mut mapped_pci_resource,
    pub tqe_prev: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_resource__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_resource__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mapped_pci_resource__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_resource__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(mapped_pci_resource__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mapped_pci_resource__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mapped_pci_resource__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_mapped_pci_resource() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_resource>(),
        4368usize,
        concat!("Size of: ", stringify!(mapped_pci_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(mapped_pci_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).pci_addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(pci_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).path as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).nb_maps as *const _ as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(nb_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_resource>())).maps as *const _ as usize },
        4128usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_resource),
            "::",
            stringify!(maps)
        )
    );
}
#[doc = " mapped pci device list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mapped_pci_res_list {
    pub tqh_first: *mut mapped_pci_resource,
    pub tqh_last: *mut *mut mapped_pci_resource,
}
#[test]
fn bindgen_test_layout_mapped_pci_res_list() {
    assert_eq!(
        ::std::mem::size_of::<mapped_pci_res_list>(),
        16usize,
        concat!("Size of: ", stringify!(mapped_pci_res_list))
    );
    assert_eq!(
        ::std::mem::align_of::<mapped_pci_res_list>(),
        8usize,
        concat!("Alignment of ", stringify!(mapped_pci_res_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_res_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_res_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapped_pci_res_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mapped_pci_res_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
extern "C" {
    #[doc = " Scan the content of the PCI bus, and the devices in the devices"]
    #[doc = " list"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  0 on success, negative on error"]
    pub fn rte_pci_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Probe the PCI bus"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - !0 on error."]
    pub fn rte_pci_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Map the PCI device resources in user space virtual memory address"]
    #[doc = ""]
    #[doc = " Note that driver should not call this function when flag"]
    #[doc = " RTE_PCI_DRV_NEED_MAPPING is set, as EAL will do that for"]
    #[doc = " you when it's on."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   A pointer to a rte_pci_device structure describing the device"]
    #[doc = "   to use"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   0 on success, negative on error and positive if no driver"]
    #[doc = "   is found for the device."]
    pub fn rte_pci_map_device(dev: *mut rte_pci_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unmap this device"]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   A pointer to a rte_pci_device structure describing the device"]
    #[doc = "   to use"]
    pub fn rte_pci_unmap_device(dev: *mut rte_pci_device);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Map a particular resource from a file."]
    #[doc = ""]
    #[doc = " @param requested_addr"]
    #[doc = "      The starting address for the new mapping range."]
    #[doc = " @param fd"]
    #[doc = "      The file descriptor."]
    #[doc = " @param offset"]
    #[doc = "      The offset for the mapping range."]
    #[doc = " @param size"]
    #[doc = "      The size for the mapping range."]
    #[doc = " @param additional_flags"]
    #[doc = "      The additional flags for the mapping range."]
    #[doc = " @return"]
    #[doc = "   - On success, the function returns a pointer to the mapped area."]
    #[doc = "   - On error, the value MAP_FAILED is returned."]
    pub fn pci_map_resource(
        requested_addr: *mut ::std::os::raw::c_void,
        fd: ::std::os::raw::c_int,
        offset: off_t,
        size: usize,
        additional_flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @internal"]
    #[doc = " Unmap a particular resource."]
    #[doc = ""]
    #[doc = " @param requested_addr"]
    #[doc = "      The address for the unmapping range."]
    #[doc = " @param size"]
    #[doc = "      The size for the unmapping range."]
    pub fn pci_unmap_resource(requested_addr: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    #[doc = " Probe the single PCI device."]
    #[doc = ""]
    #[doc = " Scan the content of the PCI bus, and find the pci device specified by pci"]
    #[doc = " address, then call the probe() function for registered driver that has a"]
    #[doc = " matching entry in its id_table for discovered device."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address to probe."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative on error."]
    pub fn rte_pci_probe_one(addr: *const rte_pci_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close the single PCI device."]
    #[doc = ""]
    #[doc = " Scan the content of the PCI bus, and find the pci device specified by pci"]
    #[doc = " address, then call the remove() function for registered driver that has a"]
    #[doc = " matching entry in its id_table for discovered device."]
    #[doc = ""]
    #[doc = " @param addr"]
    #[doc = "\tThe PCI Bus-Device-Function address to close."]
    #[doc = " @return"]
    #[doc = "   - 0 on success."]
    #[doc = "   - Negative on error."]
    pub fn rte_pci_detach(addr: *const rte_pci_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the content of the PCI bus."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_pci_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Register a PCI driver."]
    #[doc = ""]
    #[doc = " @param driver"]
    #[doc = "   A pointer to a rte_pci_driver structure describing the driver"]
    #[doc = "   to be registered."]
    pub fn rte_pci_register(driver: *mut rte_pci_driver);
}
extern "C" {
    #[doc = " Unregister a PCI driver."]
    #[doc = ""]
    #[doc = " @param driver"]
    #[doc = "   A pointer to a rte_pci_driver structure describing the driver"]
    #[doc = "   to be unregistered."]
    pub fn rte_pci_unregister(driver: *mut rte_pci_driver);
}
extern "C" {
    #[doc = " Read PCI config space."]
    #[doc = ""]
    #[doc = " @param device"]
    #[doc = "   A pointer to a rte_pci_device structure describing the device"]
    #[doc = "   to use"]
    #[doc = " @param buf"]
    #[doc = "   A data buffer where the bytes should be read into"]
    #[doc = " @param len"]
    #[doc = "   The length of the data buffer."]
    #[doc = " @param offset"]
    #[doc = "   The offset into PCI config space"]
    pub fn rte_pci_read_config(
        device: *const rte_pci_device,
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        offset: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write PCI config space."]
    #[doc = ""]
    #[doc = " @param device"]
    #[doc = "   A pointer to a rte_pci_device structure describing the device"]
    #[doc = "   to use"]
    #[doc = " @param buf"]
    #[doc = "   A data buffer containing the bytes should be written"]
    #[doc = " @param len"]
    #[doc = "   The length of the data buffer."]
    #[doc = " @param offset"]
    #[doc = "   The offset into PCI config space"]
    pub fn rte_pci_write_config(
        device: *const rte_pci_device,
        buf: *const ::std::os::raw::c_void,
        len: usize,
        offset: off_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A structure used to access io resources for a pci device."]
#[doc = " rte_pci_ioport is arch, os, driver specific, and should not be used outside"]
#[doc = " of pci ioport api."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pci_ioport {
    pub dev: *mut rte_pci_device,
    pub base: u64,
    pub len: u64,
}
#[test]
fn bindgen_test_layout_rte_pci_ioport() {
    assert_eq!(
        ::std::mem::size_of::<rte_pci_ioport>(),
        24usize,
        concat!("Size of: ", stringify!(rte_pci_ioport))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pci_ioport>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pci_ioport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_ioport>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_ioport),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_ioport>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_ioport),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_pci_ioport>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pci_ioport),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Initialize a rte_pci_ioport object for a pci device io resource."]
    #[doc = ""]
    #[doc = " This object is then used to gain access to those io resources (see below)."]
    #[doc = ""]
    #[doc = " @param dev"]
    #[doc = "   A pointer to a rte_pci_device structure describing the device"]
    #[doc = "   to use."]
    #[doc = " @param bar"]
    #[doc = "   Index of the io pci resource we want to access."]
    #[doc = " @param p"]
    #[doc = "   The rte_pci_ioport object to be initialized."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative on error."]
    pub fn rte_pci_ioport_map(
        dev: *mut rte_pci_device,
        bar: ::std::os::raw::c_int,
        p: *mut rte_pci_ioport,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release any resources used in a rte_pci_ioport object."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   The rte_pci_ioport object to be uninitialized."]
    #[doc = " @return"]
    #[doc = "  0 on success, negative on error."]
    pub fn rte_pci_ioport_unmap(p: *mut rte_pci_ioport) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read from a io pci resource."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   The rte_pci_ioport object from which we want to read."]
    #[doc = " @param data"]
    #[doc = "   A data buffer where the bytes should be read into"]
    #[doc = " @param len"]
    #[doc = "   The length of the data buffer."]
    #[doc = " @param offset"]
    #[doc = "   The offset into the pci io resource."]
    pub fn rte_pci_ioport_read(
        p: *mut rte_pci_ioport,
        data: *mut ::std::os::raw::c_void,
        len: usize,
        offset: off_t,
    );
}
extern "C" {
    #[doc = " Write to a io pci resource."]
    #[doc = ""]
    #[doc = " @param p"]
    #[doc = "   The rte_pci_ioport object to which we want to write."]
    #[doc = " @param data"]
    #[doc = "   A data buffer where the bytes should be read into"]
    #[doc = " @param len"]
    #[doc = "   The length of the data buffer."]
    #[doc = " @param offset"]
    #[doc = "   The offset into the pci io resource."]
    pub fn rte_pci_ioport_write(
        p: *mut rte_pci_ioport,
        data: *const ::std::os::raw::c_void,
        len: usize,
        offset: off_t,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[doc = " Pointer to memory configuration, which may be shared across multiple"]
#[doc = " DPDK instances"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mem_config {
    pub _address: u8,
}
